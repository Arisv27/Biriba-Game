<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Game - Full Screen Layout</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(to bottom, 
                #000 0%, 
                #000 10%, 
                #8B0000 10%, 
                #8B0000 90%, 
                #000 90%, 
                #000 100%
            );
            min-height: 150vh; /* Allow scrolling */
            overflow-x: hidden;
        }

        .game-container {
            position: relative;
            width: 100%;
            min-height: 150vh;
            padding-bottom: 200px; /* Space for fixed bottom overlay */
            padding-left: 120px; /* Balanced left margin */
            padding-right: 120px; /* Balanced right margin */
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            /* Maximize table area */
            .game-container {
                padding-left: 8px;
                padding-right: 8px;
                padding-bottom: 80px;
                min-height: 100vh;
            }
            .game-table { margin: 0; }
            /* Hide atou indicator/label and biribaki decks */
            .atou-indicator,
            .atou-label,
            .biribaki-decks,
            .player-name-label { display: none !important; }
            .team-score-box { display: none !important; }
            /* Shrink meld cards by ~60% of desktop size and make stack thinner */
            .run-cards-stack { width: 42px; }
            .run-card { width: 54px !important; height: 78px !important; }
            /* Reduce container padding/height aggressively on mobile */
            .run-display { padding: 0px 1px; min-height: 40px; border-width: 1px; }
            /* Hide run-info labels on mobile */
            .run-info { display: none !important; }

            /* Hand: shrink to ~60% and allow tighter wrapping */
            .hand-area {
                gap: 2px;
                padding: 6px;
                min-height: 90px;
            }
            .hand-card {
                width: 36px; /* smaller to fit more per row */
                height: 54px;
                margin: 1px;
            }
            .hand-card.selected { transform: translateY(-5px); border-width: 2px; }
            .hand-card:hover { transform: translateY(-2px); }
            /* Hide card picker on mobile */
            .card-picker-toggle,
            .card-picker-backdrop,
            .card-picker-sidebar { display: none !important; }

            /* Make meld areas wider on mobile */
            .meld-areas { right: 20px !important; }
            
            /* Make the side piles column thinner and closer to edge */
            .side-piles { right: 6px; gap: 10px; }
            .pile h3 { font-size: 12px; margin-bottom: 6px; }
            #stock-pile { transform: scale(0.8); }
            #discard-pile { transform: scale(0.8); }
            .view-discard-btn { padding: 3px 6px; font-size: 9px; }
        }
        /* Chat toast notifications (top-right overlay, stacked) */
        .chat-toasts {
            position: fixed;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 3000;
            pointer-events: none;
        }
        .chat-toast {
            min-width: 260px;
            max-width: 420px;
            background: linear-gradient(145deg, rgba(26,26,46,0.92) 0%, rgba(22,33,62,0.92) 60%, rgba(15,52,96,0.92) 100%);
            border-radius: 14px;
            padding: 10px 14px;
            box-shadow:
                0 14px 28px rgba(0,0,0,0.45),
                0 0 0 1px rgba(255,255,255,0.06),
                inset 0 1px 0 rgba(255,255,255,0.15);
            border: 1px solid rgba(255, 215, 0, 0.25);
            backdrop-filter: blur(8px);
            opacity: 0;
            transform: translateX(12px) translateY(-6px);
            transition: opacity 200ms ease, transform 200ms ease;
            pointer-events: none;
        }
        .chat-toast.show {
            opacity: 1;
            transform: translateX(0) translateY(0);
        }
        .chat-toast .toast-title {
            font-weight: 700;
            letter-spacing: 0.3px;
            color: #FFD700;
            margin-bottom: 3px;
            font-size: 12px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.6);
        }
        .chat-toast .toast-msg {
            font-size: 13px;
            color: #ecf0f1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
        }

        /* Toggle Button */
        .card-picker-toggle {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 3px solid #FFD700;
            border-radius: 50%;
            color: #FFD700;
            font-size: 20px;
            cursor: pointer;
            z-index: 300;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }

        .card-picker-toggle:hover {
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        }

        .card-picker-toggle.active {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        /* Atou indicator opposite the card picker */
        .atou-indicator {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #FFD700;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #FFD700;
            font-size: 22px;
            z-index: 300;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }

        .atou-indicator.hidden {
            opacity: 0.2;
            filter: grayscale(0.6);
        }

        /* Atou text label */
        .atou-label {
            position: fixed;
            right: 45px; /* center under the 50px circle with 3px border */
            top: calc(50% + 36px);
            transform: translateX(50%);
            color: #FFD700;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            z-index: 300;
            transition: opacity 0.3s ease;
        }
        .atou-label.hidden {
            opacity: 0.2;
        }

        /* Atou selection popup buttons */
        .atou-select-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 3px solid #FFD700;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #FFD700;
            font-size: 26px;
            font-weight: 800;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 8px;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0,0,0,0.45);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .atou-select-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 24px rgba(0,0,0,0.55);
        }

        .atou-select-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-top: 12px;
        }

        /* Overlay Backdrop */
        .card-picker-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 199;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .card-picker-backdrop.active {
            opacity: 1;
            visibility: visible;
        }

        /* Card Picker Overlay */
        .card-picker-sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 240px;
            height: 100vh;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-right: 3px solid #FFD700;
            z-index: 200;
            
            overflow-x: hidden;
            padding: 20px 10px;
            box-shadow: 3px 0 10px rgba(0, 0, 0, 0.3);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            
            scrollbar-color: #FFD700 #34495e;
        }

        .card-picker-sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .card-picker-sidebar::-webkit-scrollbar-track {
            background: #34495e;
        }

        .card-picker-sidebar::-webkit-scrollbar-thumb {
            background: #FFD700;
            border-radius: 4px;
        }

        .card-picker-sidebar::-webkit-scrollbar-thumb:hover {
            background: #f1c40f;
        }

        .card-picker-sidebar.active {
            transform: translateX(0);
        }

        .sidebar-header {
            color: #FFD700;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .card-category {
            margin-bottom: 15px;
        }

        .category-title {
            color: #ecf0f1;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-bottom: 10px;
        }

        .picker-card {
            width: 45px;
            height: 65px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            background: white;
            color: #333;
        }

        .picker-card:hover {
            border-color: #FFD700;
            transform: scale(1.05);
        }

        .picker-card.hearts, .picker-card.diamonds {
            color: #dc143c;
        }

        .picker-card.clubs, .picker-card.spades {
            color: #2c2c2c;
        }

        .picker-card.joker {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffd93d 50%, #ff6b6b 100%);
            color: #333;
            font-size: 8px;
        }

        .clear-hand-btn {
            width: 100%;
            padding: 10px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }

        .clear-hand-btn:hover {
            background: #c0392b;
        }

        /* Player view buttons */
        .player-view-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .player-view-btn {
            width: 100%;
            padding: 8px 12px;
            background: #34495e;
            color: #ecf0f1;
            border: 2px solid #5a6c7d;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-view-btn:hover {
            background: #4a5f7a;
            border-color: #FFD700;
        }

        .player-view-btn.active {
            background: #FFD700;
            color: #2c3e50;
            border-color: #f39c12;
        }

        .player-view-btn.active:hover {
            background: #f1c40f;
        }

        /* Discard pile history styles */
        .discard-history {
            max-height: 200px;
            
            background: rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            padding: 8px;
        }

        .discard-empty {
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            text-align: center;
            padding: 10px;
            font-size: 12px;
        }

        .discard-card {
            width: 35px;
            height: 50px;
            border-radius: 3px;
            display: inline-block;
            margin: 2px;
            font-size: 8px;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .discard-card:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .discard-card.hearts, .discard-card.diamonds {
            color: #dc143c;
        }

        .discard-card.clubs, .discard-card.spades {
            color: #2c2c2c;
        }

        .discard-card.joker {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffd93d 50%, #ff6b6b 100%);
            color: #333;
        }

        .discard-card-text {
            position: absolute;
            bottom: 1px;
            left: 1px;
            right: 1px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 7px;
            text-align: center;
            border-radius: 0 0 2px 2px;
            padding: 1px;
        }

        .game-table {
            position: relative;
            width: 90%;
            max-width: 1200px;
            height: 800px; /* Taller table for more meld space */
            margin: 100px auto 50px auto;
            background: radial-gradient(ellipse at center, #228B22 0%, #006400 100%);
            border: 12px solid #8B0000;
            border-radius: 50px;
            box-shadow: 
                inset 0 0 50px rgba(0, 0, 0, 0.3),
                0 10px 30px rgba(0, 0, 0, 0.5),
                0 0 0 4px #FFD700;
        }

        .meld-areas {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 140px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .meld-area {
            flex: 1;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            position: relative;
            max-height: 350px;
            
            overflow-x: hidden;
        }

        .meld-area::before {
            content: attr(data-area-name);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.2);
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            z-index: 1;
            pointer-events: none;
        }

        .meld-area.player1 {
            background: rgba(0, 100, 200, 0.1);
        }

        .meld-area.player2 {
            background: rgba(200, 100, 0, 0.1);
        }

        .side-piles {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            z-index: 60; /* Higher than player area */
        }

        .pile {
            text-align: center;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .pile h3 {
            font-size: 14px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .view-discard-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .view-discard-btn:hover {
            background: #2980b9;
        }

        .view-discard-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .view-discard-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Team score box styles */
        .team-score-box {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #000000;
            border-radius: 6px;
            padding: 8px 10px;
            min-width: 100px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        /* Biribaki decks (right side) */
        .biribaki-decks {
            position: fixed;
            right: 20px;
            top: 10%;
            display: flex;
            flex-direction: column;
            gap: 16px;
            z-index: 250;
            pointer-events: none;
        }
        .biribaki-deck {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            pointer-events: none;
        }
        .biribaki-deck .deck-label {
            color: #FFD700;
            font-weight: 700;
            font-size: 12px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.6);
        }
        .biribaki-deck .deck-stack {
            width: 54px;
            height: 90px;
            position: relative;
            pointer-events: none;
        }
        .biribaki-deck .deck-card {
            position: absolute;
            left: 0;
            top: 0;
            width: 54px;
            height: 90px;
            border-radius: 6px;
            border: 2px solid rgba(0,0,0,0.8);
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            box-shadow: 0 6px 14px rgba(0,0,0,0.5);
            transform: translateY(0);
        }
        .biribaki-deck .deck-card:nth-child(2) { transform: translateY(6px); }
        .biribaki-deck .deck-card:nth-child(3) { transform: translateY(12px); }
        .biribaki-deck .deck-card:nth-child(4) { transform: translateY(18px); }
        /* Biribaki neat status dots */
        .biribaki-dots {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-top: 6px;
        }
        .biribaki-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.06);
            box-shadow: inset 0 0 2px rgba(0,0,0,0.4);
            transition: all 0.2s ease;
        }
        .biribaki-dot.filled {
            background: radial-gradient(circle at 40% 35%, #fff5b3 0%, #ffd700 45%, #e6b800 100%);
            border-color: rgba(255,215,0,0.95);
            box-shadow: 0 0 10px rgba(255,215,0,0.6), inset 0 0 2px rgba(0,0,0,0.5);
        }

        .team-section {
            margin-bottom: 6px;
        }

        .team-section:last-child {
            margin-bottom: 0;
        }

        .team-label {
            color: #FFD700;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            text-align: center;
            margin-bottom: 2px;
        }

        .team-points {
            color: #FFFFFF;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
        }

        .team-points span {
            color: #FFFFFF;
            font-size: 13px;
        }

        .card, .card-back {
            width: 90px;
            height: 135px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .card-back {
            background: linear-gradient(135deg, #1a472a 0%, #2d5a3d 50%, #1a472a 100%);
            color: white;
            border: 2px solid #4a7c59;
            cursor: pointer;
        }

        .card {
            background: transparent;
            border: none;
            cursor: pointer;
        }

        .card.empty {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }

        .card.drag-over {
            border: 3px solid #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }

        /* Discard pile glow effect when card is being dragged over it */
        #discard-pile.drag-over {
            border: 3px solid #FFD700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4);
            transform: scale(1.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }


        .card.hearts, .card.diamonds {
            color: #dc143c;
        }

        .card.clubs, .card.spades {
            color: #2c2c2c;
        }

        .card.joker {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffd93d 50%, #ff6b6b 100%);
            color: #333;
        }

        /* Fixed bottom overlay */
        .player-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, 
                #DEB887 0%, 
                #D2B48C 25%, 
                #F4A460 50%, 
                #D2B48C 75%, 
                #DEB887 100%
            );
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(139, 69, 19, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(160, 82, 45, 0.1) 0%, transparent 50%);
            border-top: 4px solid #8B4513;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3);
            padding: 20px;
            z-index: 90;
            min-height: 180px;
        }

        .hand-area {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            min-height: 120px;
            padding: 15px;
            background: rgba(139, 69, 19, 0.1);
            border: 2px dashed rgba(139, 69, 19, 0.3);
            border-radius: 15px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .hand-area:empty::before {
            content: "Your Hand - Click cards from the sidebar to add them!";
            color: rgba(139, 69, 19, 0.6);
            font-style: italic;
            font-size: 16px;
        }

        .hand-card {
            width: 70px;
            height: 105px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
            margin: 2px;
            background: transparent;
            border: none;
        }

        .hand-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .hand-card.selected {
            border: 3px solid #FFD700;
            transform: translateY(-10px);
        }

        .hand-card.hearts, .hand-card.diamonds {
            color: #dc143c;
        }

        .hand-card.clubs, .hand-card.spades {
            color: #2c2c2c;
        }

        .hand-card.joker {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffd93d 50%, #ff6b6b 100%);
            color: #333;
        }

        .hand-card.dragging {
            opacity: 0.5;
            transform: rotate(5deg) scale(1.05);
            z-index: 1000;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }

        .drop-indicator {
            position: absolute;
            background-color: #FFD700;
            border-radius: 2px;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        /* Card Animation Keyframes */
        @keyframes cardDeal {
            0% {
                transform: translateY(-50px) scale(0.9);
                opacity: 0;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes cardEnter {
            0% {
                transform: translateX(100px) scale(0.8) !important;
                opacity: 0 !important;
            }
            50% {
                transform: translateX(20px) scale(0.95) !important;
                opacity: 0.8 !important;
            }
            100% {
                transform: translateX(0) scale(1) !important;
                opacity: 1 !important;
            }
        }

        @keyframes cardDiscard {
            0% {
                opacity: 1;
                z-index: 1000;
            }
            100% {
                opacity: 0;
            }
        }

        @keyframes cardMeld {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateY(-20px) scale(1.05);
                opacity: 0.9;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes cardDraw {
            0% {
                transform: translateX(100px) rotate(-10deg) scale(0.8);
                opacity: 0;
            }
            50% {
                transform: translateX(50px) rotate(-5deg) scale(0.9);
                opacity: 0.5;
            }
            100% {
                transform: translateX(0) rotate(0deg) scale(1);
                opacity: 1;
            }
        }

        @keyframes cardHover {
            0% {
                transform: translateY(0) scale(1);
            }
            100% {
                transform: translateY(-8px) scale(1.02);
            }
        }

        /* Animation Classes */
        .card-dealing {
            animation: cardDeal 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .card-entering {
            animation: cardEnter 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .card-discarding {
            animation: cardDiscard 1.2s ease-out forwards;
            z-index: 1000;
        }

        .card-melding {
            animation: cardMeld 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .card-drawing {
            animation: cardDraw 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .card-hovering {
            animation: cardHover 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .card-flash {
            animation: flash 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes flash {
            0% { background-color: transparent; }
            50% { background-color: rgba(255, 215, 0, 0.3); }
            100% { background-color: transparent; }
        }

        /* Hand controls */
        .hand-controls {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
            padding-right: 10px;
        }

        .sort-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 10;
        }

        .sort-btn:hover {
            background: #2980b9;
        }

        .sort-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Turn indicator - golden glow for current player's turn */
        .game-table.your-turn {
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.4);
            border: 3px solid #FFD700;
            animation: turnGlow 2s ease-in-out infinite alternate;
        }

        @keyframes turnGlow {
            0% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.4);
            }
            100% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 1), 0 0 80px rgba(255, 215, 0, 0.6);
            }
        }

        /* Chat System Styles - ULTRA COOL VERSION */
        .chat-container {
            width: 90%;
            max-width: 1200px;
            margin: 100px auto 20px auto;
            background: linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            border-radius: 20px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(10px);
        }

        .chat-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                rgba(52, 152, 219, 0.1) 0%, 
                transparent 25%, 
                transparent 75%, 
                rgba(155, 89, 182, 0.1) 100%);
            pointer-events: none;
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        .chat-header {
            background: linear-gradient(135deg, 
                rgba(52, 152, 219, 0.2) 0%, 
                rgba(155, 89, 182, 0.2) 50%, 
                rgba(231, 76, 60, 0.2) 100%);
            padding: 15px 25px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            backdrop-filter: blur(5px);
        }

        .chat-header h3 {
            margin: 0;
            color: #fff;
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #3498db, #9b59b6, #e74c3c);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textGlow 2s ease-in-out infinite alternate;
        }

        @keyframes textGlow {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.3); }
        }

        .typing-indicator {
            color: #3498db;
            font-style: italic;
            font-size: 14px;
            animation: typingPulse 1s ease-in-out infinite;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        @keyframes typingPulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .chat-messages {
            height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px 25px;
            background: linear-gradient(180deg, 
                rgba(26, 26, 46, 0.8) 0%, 
                rgba(22, 33, 62, 0.9) 100%);
            
            scrollbar-color: rgba(52, 152, 219, 0.5) transparent;
            position: relative;
        }

        .chat-messages::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.3) 0%, transparent 100%);
            pointer-events: none;
        }

        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #3498db, #9b59b6);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #2980b9, #8e44ad);
        }

        .chat-message {
            margin-bottom: 12px;
            padding: 12px 18px;
            border-radius: 20px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            animation: messageSlideIn 0.3s ease-out;
            backdrop-filter: blur(5px);
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .chat-message.own {
            background: linear-gradient(135deg, 
                rgba(52, 152, 219, 0.9) 0%, 
                rgba(41, 128, 185, 0.9) 100%);
            color: white;
            margin-left: auto;
            text-align: right;
            box-shadow: 
                0 8px 25px rgba(52, 152, 219, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .chat-message.own::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                rgba(255, 255, 255, 0.1) 0%, 
                transparent 50%, 
                rgba(255, 255, 255, 0.1) 100%);
            border-radius: 20px;
            pointer-events: none;
        }

        .chat-message.other {
            background: linear-gradient(135deg, 
                rgba(52, 73, 94, 0.8) 0%, 
                rgba(44, 62, 80, 0.9) 100%);
            color: #ecf0f1;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .message-header {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 5px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .message-content {
            font-size: 14px;
            line-height: 1.5;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .chat-input-container {
            display: flex;
            padding: 20px 25px;
            background: linear-gradient(135deg, 
                rgba(52, 152, 219, 0.1) 0%, 
                rgba(155, 89, 182, 0.1) 100%);
            border-top: 2px solid rgba(255, 255, 255, 0.1);
            gap: 12px;
            position: relative;
            backdrop-filter: blur(5px);
        }

        #chat-input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            background: linear-gradient(135deg, 
                rgba(26, 26, 46, 0.8) 0%, 
                rgba(22, 33, 62, 0.9) 100%);
            color: #fff;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 0 rgba(52, 152, 219, 0);
        }

        #chat-input:focus {
            border-color: #3498db;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 4px rgba(52, 152, 219, 0.3),
                0 0 20px rgba(52, 152, 219, 0.4);
            transform: translateY(-2px);
        }

        #chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }

        #chat-send-btn {
            padding: 15px 25px;
            background: linear-gradient(135deg, 
                #3498db 0%, 
                #9b59b6 50%, 
                #e74c3c 100%);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 700;
            transition: all 0.3s ease;
            box-shadow: 
                0 8px 25px rgba(52, 152, 219, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #chat-send-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
            transition: left 0.5s ease;
        }

        #chat-send-btn:hover {
            background: linear-gradient(135deg, 
                #2980b9 0%, 
                #8e44ad 50%, 
                #c0392b 100%);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 15px 35px rgba(52, 152, 219, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.3);
        }

        #chat-send-btn:hover::before {
            left: 100%;
        }

        #chat-send-btn:active {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 
                0 8px 25px rgba(52, 152, 219, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.2);
        }

        #chat-send-btn:disabled {
            background: linear-gradient(135deg, #7f8c8d, #95a5a6);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .create-run-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            margin-left: 8px;
        }

        .create-run-btn:hover {
            background: #229954;
        }

        .create-run-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .create-set-btn {
            background: #e67e22;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            margin-left: 8px;
        }

        .create-set-btn:hover {
            background: #d35400;
        }

        .create-set-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .extend-meld-btn {
            background: #9b59b6;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            margin-left: 8px;
        }

        .extend-meld-btn:hover {
            background: #8e44ad;
        }

        .extend-meld-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .extend-meld-btn.active {
            background: #e74c3c;
        }

        .extend-meld-btn.active:hover {
            background: #c0392b;
        }

        /* Disabled button states */
        .create-run-btn.disabled,
        .create-set-btn.disabled,
        .extend-meld-btn.disabled {
            background: #7f8c8d !important;
            cursor: not-allowed !important;
            opacity: 0.6;
        }

        .create-run-btn.disabled:hover,
        .create-set-btn.disabled:hover,
        .extend-meld-btn.disabled:hover {
            background: #7f8c8d !important;
            transform: none !important;
        }

        /* Custom popup styles */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .popup {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .popup h3 {
            color: #FFD700;
            margin-bottom: 15px;
            font-size: 18px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .popup p {
            color: #ecf0f1;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .popup-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .popup-btn:hover {
            background: #229954;
        }

        .popup-btn.error {
            background: #e74c3c;
        }

        .popup-btn.error:hover {
            background: #c0392b;
        }

        /* Run display in meld area */
        .run-display {
            position: relative;
            margin: 2px;
            padding: 10px 10px 10px 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border: 2px solid #FFD700;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .run-cards-stack {
            position: relative;
            width: 70px;
            height: auto;
            margin-top: 3px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .run-card {
            position: absolute;
            width: 78px;
            height: 113px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            box-shadow: none;
            background: transparent;
            border: none;
            left: 50%;
            transform: translateX(-50%);
        }

        .run-info {
            color: #FFD700;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            margin: 5px;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.8);
            color: #FFD700;
            text-align: center;
            padding: 15px;
            z-index: 100;
            border-bottom: 2px solid #FFD700;
        }

        .header h1 {
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* Game controls */
        .game-controls {
            position: absolute;
            top: -80px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s ease;
        }

        .control-btn:hover {
            background: #45a049;
        }

        .control-btn.danger {
            background: #f44336;
        }

        .control-btn.danger:hover {
            background: #da190b;
        }

        .help-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .help-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 50%;
        }

        .help-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .help-button:hover::before {
            opacity: 1;
        }

        .help-icon {
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 1;
            position: relative;
        }

        .help-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
        }


        /* Player name labels */
        .player-name-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            border-radius: 8px;
            padding: 8px 12px;
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 80;
            min-width: 80px;
            text-align: center;
            transition: all 0.3s ease;
        }

        /* Current turn player glow effect */
        .player-name-label.current-turn {
            animation: glow 2s ease-in-out infinite alternate;
            border-color: #FFD700;
            box-shadow: 0 0 10px #FFD700;
        }

        @keyframes glow {
            from { 
                box-shadow: 0 0 5px #FFD700, 0 0 10px #FFD700; 
            }
            to { 
                box-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700, 0 0 30px #FFD700; 
            }
        }

        /* Position labels around the game table */
        .player-name-bottom {
            bottom: -55px; /* Extend 2 more pixels outside the bottom of the table */
            left: 50%;
            transform: translateX(-50%);
        }

        .player-name-right {
            right: -105px; /* Extend 2 more pixels outside the right of the table */
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
        }

        .player-name-top {
            top: -55px; /* Extend 2 more pixels outside the top of the table */
            left: 50%;
            transform: translateX(-50%);
        }

        .player-name-left {
            left: -105px; /* Extend 2 more pixels outside the left of the table */
            top: 50%;
            transform: translateY(-50%) rotate(90deg);
        }

        /* Login Screen Styles */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, 
                #000 0%, 
                #000 10%, 
                #8B0000 10%, 
                #8B0000 90%, 
                #000 90%, 
                #000 100%
            );
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .login-container {
            max-height: 90vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 215, 0, 0.5) rgba(0, 0, 0, 0.2);
            
            
            
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 40px 40px 60px 40px;
            text-align: center;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
        }

        /* Custom scrollbar for login container */
        .login-container::-webkit-scrollbar {
            width: 8px;
        }

        .login-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .login-container::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.6);
            border-radius: 4px;
        }

        .login-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.8);
        }

        .login-container {
            max-width: 600px;
            width: 90%;
        }

        .login-header h1 {
            color: #FFD700;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .login-header p {
            color: #ecf0f1;
            font-size: 1.2em;
            margin-bottom: 30px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .player-slots {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .player-slot {
            background: rgba(0, 0, 0, 0.3);
            border: 3px solid #5a6c7d;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .player-slot:hover {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .player-slot.selected {
            border-color: #27ae60;
            background: rgba(39, 174, 96, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        .player-slot.selected:hover {
            border-color: #229954;
            background: rgba(34, 153, 84, 0.3);
        }

        .player-slot.selected .slot-number {
            color: #27ae60;
        }

        .player-slot.taken {
            border-color: #7f8c8d;
            background: rgba(127, 140, 157, 0.2);
            cursor: default;
        }

        .player-slot.taken:hover {
            border-color: #7f8c8d;
            background: rgba(127, 140, 157, 0.2);
            transform: none;
            box-shadow: none;
        }

        .player-slot.taken .slot-number {
            color: #7f8c8d;
        }

        .player-slot.selected .join-btn {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            cursor: default;
        }

        .player-slot.selected .join-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            transform: none;
        }

        .leave-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .leave-btn:hover {
            background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .leave-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .seat-taken-text {
            color: #7f8c8d;
            font-size: 1em;
            font-weight: bold;
            font-style: italic;
            padding: 12px 24px;
        }

        .slot-number {
            font-size: 3em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
        }

        .slot-label {
            color: #ecf0f1;
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .join-btn {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .join-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .join-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .player-name-input {
            width: 100%;
            padding: 8px 12px;
            margin: 8px 0;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #ecf0f1;
            font-size: 0.9em;
            text-align: center;
            transition: all 0.3s ease;
        }

        .player-name-input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
            background: rgba(0, 0, 0, 0.5);
        }

        .player-name-input::placeholder {
            color: rgba(236, 240, 241, 0.6);
            font-style: italic;
        }

        .login-footer {
            border-top: 2px solid rgba(255, 215, 0, 0.3);
            padding-top: 20px;
        }

        /* Host Settings Bar */
        .host-settings-bar {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.08) 0%, rgba(255, 215, 0, 0.03) 50%, rgba(255, 215, 0, 0.08) 100%);
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 12px;
            padding: 12px 16px;
            margin: 10px auto;
            max-width: 350px;
            
            
            
            
            backdrop-filter: blur(8px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            
            
            
            
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.1) 0%, 
                rgba(255, 215, 0, 0.05) 50%, 
                rgba(255, 215, 0, 0.1) 100%);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 12px 16px;
            margin: 10px auto;
            max-width: 350px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }


        .host-settings-bar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .host-settings-bar::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 3px;
        }

        .host-settings-bar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.7);
        }

        .settings-toggle-container {
            gap: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 4px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            min-width: 60px;
            height: 32px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 25px;
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 215, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            min-width: 200px;
            justify-content: space-between;
            overflow: hidden;
        }

        .settings-toggle:hover {
            background: rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.02);
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.2);
        }

        .settings-toggle.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 215, 0, 0.1) 100%);
            border-color: rgba(255, 215, 0, 0.6);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            background: rgba(255, 215, 0, 0.2);
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .toggle-slider {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
            border-radius: 50%;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1);
            width: 20px;
            height: 20px;
            background: #7f8c8d;
            border-radius: 50%;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .settings-toggle.active .toggle-slider {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            transform: translateY(-50%) translateX(28px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.2);
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
            border-radius: 50%;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1);
            background: #FFD700;
            transform: translateX(0);
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.4);
        }

        .toggle-label {
            color: #ecf0f1;
            font-weight: 500;
            font-size: 13px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            margin-left: 40px;
            transition: all 0.3s ease;
            color: #ecf0f1;
            font-weight: 600;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .settings-info {
            font-size: 11px;
            color: rgba(236, 240, 241, 0.8);
            font-size: 12px;
            font-style: italic;
            text-align: center;
            transition: all 0.3s ease;
        }

        .settings-toggle.active .toggle-label {
            color: #ecf0f1;
            font-weight: 500;
            font-size: 13px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            margin-left: 40px;
            transition: all 0.3s ease;
            color: #FFD700;
        }

        /* Settings Option Container */
        .settings-option-container {
            margin-top: 12px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            margin-top: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.15);
        }

        .settings-option-container:hover {
            background: rgba(0, 0, 0, 0.25);
            border-color: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
            background: rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.25);
            transform: translateY(-1px);
        }

        .settings-option-label {
            color: #ecf0f1;
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            margin-bottom: 4px;
            letter-spacing: 0.5px;
            font-size: 13px;
            color: #ecf0f1;
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            margin-bottom: 5px;
        }

        .settings-value-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .value-btn {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ecf0f1;
            padding: 8px 16px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            font-size: 12px;
            min-width: 45px;
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.3);
            color: #ecf0f1;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
            min-width: 50px;
        }

        .value-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px) scale(1.05);
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.5);
            transform: translateY(-1px);
        }

        .value-btn.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0.1) 100%);
            border-color: rgba(255, 215, 0, 0.6);
            color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            background: rgba(255, 215, 0, 0.2);
            border-color: #FFD700;
            color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .value-btn:active {
            transform: translateY(0) scale(0.95);
        }

        .start-game-btn {
            background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: not-allowed;
            margin-bottom: 10px;
            opacity: 0.6;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .future-note {
            color: rgba(236, 240, 241, 0.7);
            font-size: 0.9em;
            font-style: italic;
            margin: 0;
        }

        /* Hide main game initially */
        .game-container,
        .card-picker-toggle,
        .card-picker-backdrop,
        .card-picker-sidebar {
            display: none;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .game-container {
                padding-left: 0;
            }
            
            .card-picker-sidebar {
                width: 200px;
            }
            
            .game-table {
                width: 95%;
                height: 600px;
            }
            
            .card, .card-back, .hand-card {
                width: 60px;
                height: 90px;
                font-size: 12px;
            }

            /* Adjust player name labels for mobile */
            .player-name-left {
                left: 20px;
            }

            .player-name-right {
                right: 20px;
            }

            .player-name-label {
                font-size: 12px;
                padding: 6px 10px;
            }

            /* Login screen mobile adjustments */
            .login-container {
            max-height: 90vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 215, 0, 0.5) rgba(0, 0, 0, 0.2);
            
            
            
                padding: 30px 20px;
                margin: 20px;
            }

            .login-header h1 {
                font-size: 2em;
            }

            .player-slots {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .slot-number {
                font-size: 2.5em;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-overlay" id="login-overlay">
        <div class="login-container">
            <div class="login-header">
                <h1> BIRIBA </h1>
                <p>Choose your player position</p>
            </div>
            <div class="host-settings-bar" id="host-settings-bar" style="display: none;">
                <div class="settings-toggle-container">
                    <div class="settings-toggle" id="random-start-toggle" onclick="toggleRandomStartingPlayer()">
                        <div class="toggle-slider" id="random-start-slider"></div>
                        <span class="toggle-label"> Random Starting Player</span>
                    </div>
                    <div class="settings-info" id="random-start-info">
                        Off - Game starts with Player 1
                    </div>
                    
                    <div class="settings-toggle" id="disable-sets-toggle" onclick="toggleDisableSets()">
                        <div class="toggle-slider" id="disable-sets-slider"></div>
                        <span class="toggle-label"> Disable Sets</span>
                    </div>
                    <div class="settings-info" id="disable-sets-info">
                        Off - Sets are allowed
                    </div>
                    
                    <div class="settings-option-container">
                        <div class="settings-option-label"> 13-Card Run Base Value</div>
                        <div class="settings-value-selector">
                            <button class="value-btn" id="run-base-1000" onclick="setRunBaseValue(1000)">1000</button>
                            <button class="value-btn active" id="run-base-2000" onclick="setRunBaseValue(2000)">2000</button>
                        </div>
                        <div class="settings-info" id="run-base-info">
                            Clean runs: 2000, Dirty runs: 1000
                        </div>
                    </div>
                    
                    <div class="settings-option-container">
                        <div class="settings-option-label"> Atou Biriba Value</div>
                        <div class="settings-value-selector">
                            <button class="value-btn active" id="atou-value-400" onclick="setAtouValue(400)">400</button>
                            <button class="value-btn" id="atou-value-600" onclick="setAtouValue(600)">600</button>
                        </div>
                        <div class="settings-info" id="atou-value-info">
                            Clean atou: 400, Dirty atou: 200
                        </div>
                    </div>                </div>
            </div>
            <div class="player-slots">
                <div class="player-slot" data-player="1">
                    <div class="slot-number">1</div>
                    <div class="slot-label">Player 1</div>
                    <input type="text" class="player-name-input" id="name-input-1" placeholder="Enter name (max 16 chars)" maxlength="16">
                    <button class="join-btn" onclick="joinAsPlayer(1)">Join</button>
                </div>
                <div class="player-slot" data-player="2">
                    <div class="slot-number">2</div>
                    <div class="slot-label">Player 2</div>
                    <input type="text" class="player-name-input" id="name-input-2" placeholder="Enter name (max 16 chars)" maxlength="16">
                    <button class="join-btn" onclick="joinAsPlayer(2)">Join</button>
                </div>
                <div class="player-slot" data-player="3">
                    <div class="slot-number">3</div>
                    <div class="slot-label">Player 3</div>
                    <input type="text" class="player-name-input" id="name-input-3" placeholder="Enter name (max 16 chars)" maxlength="16">
                    <button class="join-btn" onclick="joinAsPlayer(3)">Join</button>
                </div>
                <div class="player-slot" data-player="4">
                    <div class="slot-number">4</div>
                    <div class="slot-label">Player 4</div>
                    <input type="text" class="player-name-input" id="name-input-4" placeholder="Enter name (max 16 chars)" maxlength="16">
                    <button class="join-btn" onclick="joinAsPlayer(4)">Join</button>
                </div>
            </div>
            <div class="login-footer">
                <button class="start-game-btn" onclick="startGame()" disabled>Start Game</button>
                <p class="future-note">* Start Game button for future multiplayer implementation</p>
                <div style="margin-top:12px; display:flex; gap:10px; justify-content:center;">
                    <button class="join-btn" onclick="joinAsSpectator()" title="Watch only">Join as Spectator</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toggle Button -->
    <button class="card-picker-toggle" id="card-picker-toggle"></button>
    <!-- Atou Indicator -->
    <div class="atou-indicator hidden" id="atou-indicator">?</div>
    <div class="atou-label hidden" id="atou-label">ATOU</div>
    
    <!-- Biribaki decks (right side) -->
    <div class="biribaki-decks" id="biribaki-decks">
        <div class="biribaki-deck" id="team1-biribaki-deck">
            <div class="deck-label">Team 1</div>
            <div class="deck-stack">
                <div class="deck-card"></div>
                <div class="deck-card"></div>
                <div class="deck-card"></div>
                <div class="deck-card"></div>
            </div>
        </div>
        <div class="biribaki-deck" id="team2-biribaki-deck">
            <div class="deck-label">Team 2</div>
            <div class="deck-stack">
                <div class="deck-card"></div>
                <div class="deck-card"></div>
                <div class="deck-card"></div>
                <div class="deck-card"></div>
            </div>
        </div>
    </div>
    
    <!-- Backdrop -->
    <div class="card-picker-backdrop" id="card-picker-backdrop"></div>
    
    <!-- Card Picker Sidebar -->
    <div class="card-picker-sidebar" id="card-picker-sidebar">
        <div class="sidebar-header"> Card Picker</div>
        
        <div class="card-category">
            <div class="category-title"> Spades</div>
            <div class="card-grid" id="spades-grid"></div>
        </div>
        
        <div class="card-category">
            <div class="category-title"> Hearts</div>
            <div class="card-grid" id="hearts-grid"></div>
        </div>
        
        <div class="card-category">
            <div class="category-title"> Diamonds</div>
            <div class="card-grid" id="diamonds-grid"></div>
        </div>
        
        <div class="card-category">
            <div class="category-title"> Clubs</div>
            <div class="card-grid" id="clubs-grid"></div>
        </div>
        
        <div class="card-category">
            <div class="category-title"> Jokers</div>
            <div class="card-grid" id="jokers-grid"></div>
        </div>
        
        <div class="card-category">
            <div class="category-title"> Discard Pile History</div>
            <div class="discard-history" id="discard-history">
                <div class="discard-empty">No cards discarded yet</div>
            </div>
        </div>
        
        <div class="card-category">
            <div class="category-title"> Player View</div>
            <div class="player-view-buttons">
                <button class="player-view-btn active" data-player="1" onclick="switchPlayerView(1)">Player 1</button>
                <button class="player-view-btn" data-player="2" onclick="switchPlayerView(2)">Player 2</button>
                <button class="player-view-btn" data-player="3" onclick="switchPlayerView(3)">Player 3</button>
                <button class="player-view-btn" data-player="4" onclick="switchPlayerView(4)">Player 4</button>
            </div>
        </div>
        
        <div class="card-category">
            <div class="category-title"> Dev Tools</div>
            <div class="player-view-buttons">
                <button class="player-view-btn" onclick="addSevenCardRunToHand()">Add 7-card Run (replace hand)</button>
                <button class="player-view-btn" onclick="biribakiCardChecker()">Biribaki Card Checker</button>
                <button class="player-view-btn" onclick="skipTurn()">Skip Turn</button>
                <button class="player-view-btn" id="force-resync-btn" onclick="forceResyncAll()" title="Host only">Force Resync</button>
            </div>
        </div>
        
        <button class="clear-hand-btn" onclick="clearHand()">Clear Hand</button>
    </div>

    <!-- Chat Toast Container -->
    <div class="chat-toasts" id="chat-toasts"></div>

    <div class="game-container">
        <div class="game-table">
            <div id="spectator-count" style="position: fixed; top: 10px; left: 10px; color: #FFD700; font-weight: 700; text-shadow: 0 1px 2px rgba(0,0,0,0.6); z-index: 1500;">Spectators: 0</div>
            <!-- Player name labels positioned around the game table -->
            <div class="player-name-label player-name-bottom" id="player-name-bottom">
                <span class="player-name-text">Player 1</span>
            </div>
            
            <div class="player-name-label player-name-right" id="player-name-right">
                <span class="player-name-text">Player 2</span>
            </div>
            
            <div class="player-name-label player-name-top" id="player-name-top">
                <span class="player-name-text">Player 3</span>
            </div>
            
            <div class="player-name-label player-name-left" id="player-name-left">
                <span class="player-name-text">Player 4</span>
            </div>
            <div class="game-controls">
                <button class="help-button" onclick="showGameInstructions()" title="Game Instructions">
                    <span class="help-icon">?</span>
                </button>
            </div>


            <div class="meld-areas">
                <div class="meld-area player1" data-area-name="Player 1 Play Area">
                </div>
                <div class="meld-area player2" data-area-name="Player 2 Play Area">
                </div>
            </div>

            <div class="side-piles">
                <div class="pile">
                    <h3>Stock Pile</h3>
                    <div class="card-back" id="stock-pile" onclick="drawCard()">52</div>
                </div>
                <div class="pile">
                    <h3>Discard Pile</h3>
                    
                    <div class="card diamonds" id="discard-pile" style="background-image: url('cards/6_of_diamonds.png');
                              background-size: contain;
                              background-position: center center;
                              background-repeat: no-repeat;
                              cursor: pointer;">
                    </div>
                    
                    <button class="view-discard-btn" id="view-discard-btn" onclick="showDiscardPilePopup()">View All</button>
                </div>
                <div class="pile">
                    <div class="team-score-box">
                        <div class="team-section">
                            <div class="team-label">Team one:</div>
                        <div class="biribaki-dots" id="team1-biribaki-dots">
                            <div class="biribaki-dot" data-idx="1"></div>
                            <div class="biribaki-dot" data-idx="2"></div>
                        </div>
                            <div class="team-points"><span id="team1-score">0</span></div>
                        </div>
                        <div class="team-section">
                            <div class="team-label">Team two:</div>
                        <div class="biribaki-dots" id="team2-biribaki-dots">
                            <div class="biribaki-dot" data-idx="1"></div>
                            <div class="biribaki-dot" data-idx="2"></div>
                        </div>
                            <div class="team-points"><span id="team2-score">0</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat System -->
        <div class="chat-container">
            <div class="chat-header">
                <h3>Chat</h3>
                <div class="typing-indicator" id="typing-indicator" style="display: none;">
                    <span id="typing-text"></span>
                </div>
            </div>
            <div class="chat-messages" id="chat-messages">
                <!-- Messages will appear here -->
            </div>
            <div class="chat-input-container">
                <input type="text" id="chat-input" placeholder="Type a message..." maxlength="200">
                <button id="chat-send-btn">Send</button>
            </div>
        </div>

        <div class="player-area">
            <div class="hand-controls">
                <button class="sort-btn" id="sort-btn" onclick="toggleSort()">Sort by Rank</button>
                <button class="create-run-btn" id="create-run-btn">Create Run</button>
                <button class="create-set-btn" id="create-set-btn">Create Set</button>
                <button class="extend-meld-btn" id="extend-meld-btn">Extend Meld</button>
            </div>
            <div class="hand-area" id="player-hand">
                <!-- Player hand will go here -->
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Socket.IO connection
        const socket = io();
        
        // Socket.IO event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            // On reconnect, request a fullState to resync quickly
            if (loginState && loginState.hasJoined) {
                socket.emit('requestFullState');
            }
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
        });
        
        socket.on('seatGranted', (data) => {
            console.log('Seat granted:', data);
            const { seat, playerName } = data;
            
            // Update login state
            loginState.myPlayerId = seat;
            loginState.selectedPlayer = seat;
            loginState.hasJoined = true;
            
            // Store player name
            if (playerName) {
                playerNames[seat] = playerName;
                console.log(`Player ${seat} name set to: ${playerName}`);
            }
            
            // Add self to joined players
            joinedPlayers.add(seat);
            
            // Update UI
            updateAllSlotDisplays();
            updateHostSettingsVisibility();
            
            console.log(`Successfully joined as Player ${seat} with name: ${playerNames[seat]}`);
        });
        
        socket.on('seatDenied', (data) => {
            console.log('Seat denied:', data);
            const { error } = data;
            
            showPopup('Seat Unavailable', `Cannot join seat: ${error}`, true);
        });
        
        // Sound system
        const cardSoundAudio = new Audio('sounds/card-sounds-35956.mp3');
        const flipcardSoundAudio = new Audio('sounds/flipcard-91468.mp3');
        const dragSoundAudio = new Audio('sounds/cardsound32562-37691.mp3');
        const successSoundAudio = new Audio('sounds/short-success-sound-glockenspiel-treasure-video-game-6346.mp3');
        const biribakiSoundAudio = new Audio('sounds/game-bonus-144751.mp3')
        const gameEndSoundAudio = new Audio('sounds/068232_successwav-82815.mp3')
        const meldSuccessSoundAudio = new Audio('sounds/success-221935.mp3');
        const chatNotifySoundAudio = new Audio('sounds/new-notification-010-352755.mp3');
        const chatSendSoundAudio = new Audio('sounds/happy-pop-2-185287.mp3');
        const yourTurnSoundAudio = new Audio('sounds/fantasy-game-sword-cut-sound-effect-get-more-on-my-patreon-339824.mp3');
        cardSoundAudio.volume = 0.3; // Set volume to 30%
        flipcardSoundAudio.volume = 0.4; // Set volume to 40%
        dragSoundAudio.volume = 0.3; // Set volume to 30%
        successSoundAudio.volume = 0.5; // Set volume to 50%
        meldSuccessSoundAudio.volume = 0.4; // Set volume to 40%
        chatNotifySoundAudio.volume = 0.35; // Set volume to 35%
        chatSendSoundAudio.volume = 0.35; // Set volume to 35%
        gameEndSoundAudio.volume = 0.6; // Set volume to 60%
        yourTurnSoundAudio.volume = 0.4;
        
        function playBiribakiSound(){
            const audioClone = biribakiSoundAudio.cloneNode();
            audioClone.volume = 0.5;
            audioClone.play().catch(error => {
                console.log('Biribaki sound play failed:', error);
            });
        }

        function playMeldSuccessSound() {
            const audioClone = meldSuccessSoundAudio.cloneNode();
            audioClone.volume = 0.4;
            audioClone.play().catch(error => {
                console.log('Meld success sound play failed:', error);
            });
        }

        function playGameEndSound() {
            const audioClone = gameEndSoundAudio.cloneNode();
            audioClone.volume = 0.6;
            audioClone.play().catch(error => {
                console.log('Game end sound play failed:', error);
            });
        }

        function playChatNotifySound() {
            const audioClone = chatNotifySoundAudio.cloneNode();
            audioClone.volume = 0.35;
            audioClone.play().catch(error => {
                console.log('Chat notify sound play failed:', error);
            });
        }

        function playChatSentSound() {
            const audioClone = chatSendSoundAudio.cloneNode();
            audioClone.volume = 0.35;
            audioClone.play().catch(error => {
                console.log('Chat sent sound play failed:', error);
            });
        }

        function playYourTurnSound() {
            const audioClone = yourTurnSoundAudio.cloneNode();
            audioClone.volume = 0.4;
            audioClone.play().catch(error => {
                console.log('Your turn sound play failed:', error);
            });
        }

        function playCardSound() {
            // Clone the audio to allow overlapping sounds
            const audioClone = cardSoundAudio.cloneNode();
            audioClone.volume = 0.3;
            audioClone.play().catch(error => {
                console.log('Sound play failed:', error);
            });
        }
        
        function playSuccessSound() {
            // Clone the audio to allow overlapping sounds
            const audioClone = successSoundAudio.cloneNode();
            audioClone.volume = 0.5;
            audioClone.play().catch(error => {
                console.log('Success sound play failed:', error);
            });
        }

        function playDragSound() {
            // Clone the audio to allow overlapping sounds
            const audioClone = dragSoundAudio.cloneNode();
            audioClone.volume = 0.3;
            audioClone.play().catch(error => {
                console.log('Drag sound play failed:', error);
            });
        }

        function playFlipcardSound() {
            // Clone the audio to allow overlapping sounds
            const audioClone = flipcardSoundAudio.cloneNode();
            audioClone.volume = 0.4;
            audioClone.play().catch(error => {
                console.log('Flipcard sound play failed:', error);
            });
        }

        function playCardSoundDelayed(delay = 0) {
            setTimeout(() => {
                playCardSound();
            }, delay);
        }

        // Chat System
        let chatMessages = [];
        let typingTimeout;
        let isTyping = false;

        function initializeChat() {
            const chatInput = document.getElementById('chat-input');
            const chatSendBtn = document.getElementById('chat-send-btn');
            const chatMessagesElement = document.getElementById('chat-messages');

            // Send message on button click
            chatSendBtn.addEventListener('click', sendMessage);

            // Send message on Enter key
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            // Typing indicator
            chatInput.addEventListener('input', () => {
                if (!isTyping) {
                    isTyping = true;
                    socket.emit('typing', { playerId: loginState.myPlayerId, isTyping: true });
                }

                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    isTyping = false;
                    socket.emit('typing', { playerId: loginState.myPlayerId, isTyping: false });
                }, 1000);
            });
        }

        function sendMessage() {
            const chatInput = document.getElementById('chat-input');
            const message = chatInput.value.trim();

            if (message && loginState.myPlayerId) {
                const messageData = {
                    message: message,
                    playerId: loginState.myPlayerId,
                    timestamp: new Date().toLocaleTimeString()
                };

                // Send to server
                socket.emit('chat', messageData);

                // Add to local messages
                addMessage(messageData, true);

                // Play send sound for own message
                playChatSentSound();

                // Clear input
                chatInput.value = '';
            }
        }

        function addMessage(messageData, isOwn = false) {
            const chatMessagesElement = document.getElementById('chat-messages');
            const messageElement = document.createElement('div');
            messageElement.className = `chat-message ${isOwn ? 'own' : 'other'}`;

            const playerName = playerNames[messageData.playerId] || `Player ${messageData.playerId}`;
            messageElement.innerHTML = `
                <div class="message-header">${playerName}  ${messageData.timestamp}</div>
                <div class="message-content">${messageData.message}</div>
            `;

            chatMessagesElement.appendChild(messageElement);
            chatMessagesElement.scrollTop = chatMessagesElement.scrollHeight;

            // Store message
            chatMessages.push(messageData);
            if (chatMessages.length > 50) {
                chatMessages.shift();
            }

            // Show transient toast preview for incoming messages from others
            if (!isOwn) {
                showChatToast(messageData);
            }
        }

        function showTypingIndicator(playerId, isTyping) {
            const typingIndicator = document.getElementById('typing-indicator');
            const typingText = document.getElementById('typing-text');

            if (isTyping) {
                const playerName = playerNames[playerId] || `Player ${playerId}`;
                typingText.textContent = `${playerName} is typing...`;
                typingIndicator.style.display = 'block';
            } else {
                typingIndicator.style.display = 'none';
            }
        }
        
        // Refresh all chat messages with updated player names
        function refreshChatMessages() {
            const chatMessagesElement = document.getElementById('chat-messages');
            if (!chatMessagesElement) return;
            
            // Clear existing messages
            chatMessagesElement.innerHTML = '';
            
            // Re-add all messages with updated names
            chatMessages.forEach(messageData => {
                const isOwn = messageData.playerId === loginState.myPlayerId;
                addMessage(messageData, isOwn);
            });
        }

        // Create a short-lived chat toast in the top-right
        function showChatToast(messageData) {
            try {
                const container = document.getElementById('chat-toasts');
                if (!container) return;
                const name = playerNames[messageData.playerId] || `Player ${messageData.playerId}`;
                const preview = String(messageData.message || '').trim();
                const toast = document.createElement('div');
                toast.className = 'chat-toast';
                toast.innerHTML = `<div class="toast-title">${name}</div><div class="toast-msg"></div>`;
                const msgEl = toast.querySelector('.toast-msg');
                // Truncate in UI (CSS ellipsis), but also limit length to ~60 chars for accessibility
                msgEl.textContent = preview.length > 60 ? preview.slice(0, 57) + '' : preview;
                // Cap number of visible toasts (keep latest 4)
                const existing = Array.from(container.querySelectorAll('.chat-toast'));
                if (existing.length >= 4) {
                    const toRemove = existing.slice(0, existing.length - 3);
                    toRemove.forEach(el => el.parentNode && el.parentNode.removeChild(el));
                }
                container.appendChild(toast);
                // Force reflow to enable transition
                void toast.offsetWidth; // eslint-disable-line no-unused-expressions
                toast.classList.add('show');
                // Auto-remove after 3.5s
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (toast.parentNode) toast.parentNode.removeChild(toast);
                    }, 200);
                }, 3500);
            } catch (e) {
                console.error('Failed to show chat toast:', e);
            }
        }
        
        socket.on('seatUpdate', (data) => {
            console.log('Seat update received:', data);
            const { seats, spectators } = data;
            
            // Update taken seats and joined players
            loginState.takenSeats.clear();
            joinedPlayers.clear();
            if (loginState.myPlayerId) {
                joinedPlayers.add(loginState.myPlayerId);
            }
            
            Object.keys(seats).forEach(seatNum => {
                const seatNumber = parseInt(seatNum);
                if (seats[seatNum].occupied) {
                    if (seatNumber !== loginState.myPlayerId) {
                    loginState.takenSeats.add(seatNumber);
                    }
                    joinedPlayers.add(seatNumber);
                    
                    // Update player name if provided
                    if (seats[seatNum].playerName) {
                        playerNames[seatNumber] = seats[seatNum].playerName;
                        console.log(`Updated Player ${seatNumber} name to: ${playerNames[seatNumber]}`);
                    }
                }
                
                // Update host status
                if (seats[seatNum].isHost && seatNumber === loginState.myPlayerId) {
                    loginState.isHost = true;
                } else if (loginState.myPlayerId && seatNumber === loginState.myPlayerId) {
                    loginState.isHost = false;
                }
            });
            
            // Update UI
            updateAllSlotDisplays();
            updateStartGameButton();
            updateMeldAreaLabels();
            refreshChatMessages();
            updateHostSettingsVisibility();
            if (typeof spectators === 'number') {
                const specBadge = document.getElementById('spectator-count');
                if (specBadge) specBadge.textContent = `Spectators: ${spectators}`;
            }
        });
        
        socket.on('startGameDenied', (data) => {
            console.log('Start game denied:', data);
            const { error } = data;
            showPopup('Cannot Start Game', `Failed to start game: ${error}`, true);
        });
        
        socket.on('gameStarted', (data) => {
            console.log('Game started by host:', data);
            const { fullState } = data;
            
            // Apply the received fullState to all clients
            applyFullState(fullState);
            
            // Start the game for all clients
            startGameFromHost();
            
            showPopup('Game Started!', 'The host has started the game. Good luck!', false);
        });
        
        // Handle remote actions from other players (Phase 5: Basic Actions + Phase 6: Meld Sync)
        socket.on('remoteAction', (data) => {
            console.log('Received remote action:', data);
            const { type, cardId, playerSeat, kind, cards, newHand } = data;
            
            // Apply the same action that the remote player performed
            switch (type) {
                case 'drawStock':
                    applyDrawStockAction(playerSeat);
                    break;
                case 'pickDiscard':
                    applyPickDiscardAction(playerSeat);
                    break;
                case 'discard':
                    console.log(`Player ${loginState.myPlayerId} has received the discard from Player ${playerSeat}`);
                    applyDiscardAction(playerSeat, cardId);
                    break;
                case 'meldCreate':
                    applyMeldCreateAction(playerSeat, kind, cards);
                    break;
                case 'devSevenCardRun':
                    applyDevSevenCardRunAction(playerSeat, data.newHand);
                    break;
                case 'biribakiPreview':
                    applyBiribakiPreviewAction(data.playerId, data.team);
                    break;
                case 'devToolsOpened':
                    showPopup('Dev Tools Alert', `Player ${data.playerId} has opened the dev tools!`, false);
                    break;
                case 'skipTurn':
                    applySkipTurnAction(data.playerId);
                    break;
                case 'setAtouSuit':
                    if (data.suit) {
                        gameState.atouSuit = data.suit;
                        gameState.atouPending = false;
                        updateAtouIndicator();
                    }
                    break;
                default:
                    console.log('Unknown remote action type:', type);
            }
        });

        // Resync channel: host broadcasts checksum; clients compare and request full state on mismatch
        socket.on('stateChecksum', (data) => {
            try {
                const localChecksum = computeFullStateChecksum(gameStateToFullState());
                if (data && data.checksum && localChecksum !== data.checksum) {
                    console.warn('Checksum mismatch detected. Requesting fullState resync...');
                    socket.emit('requestFullState');
                }
            } catch (e) {
                console.error('Error comparing checksum:', e);
            }
        });

        // Server forwards request to host; if we are host, respond with fullState
        socket.on('requestFullState', (payload) => {
            if (!loginState.isHost) return;
            try {
                const fs = gameStateToFullState();
                const checksum = computeFullStateChecksum(fs);
                const to = payload && payload.requester;
                if (to) {
                    socket.emit('fullStateUpdate', { to, fullState: fs, checksum });
                }
            } catch (e) {
                console.error('Failed to send fullStateUpdate:', e);
            }
        });

        // Receive a fullState from host and apply
        socket.on('fullStateUpdate', (data) => {
            try {
                if (!data || !data.fullState) return;
                applyFullState(data.fullState);
                console.log('Applied fullStateUpdate from host');
            } catch (e) {
                console.error('Error applying fullStateUpdate:', e);
            }
        });

        // Host-only utility to force broadcast a fullState to everyone
        function forceResyncAll() {
            if (!loginState.isHost) {
                showPopup('Not Host', 'Only the host can force resync.', true);
                return;
            }
            try {
                const fs = gameStateToFullState();
                const checksum = computeFullStateChecksum(fs);
                // Broadcast checksum first to prompt clients, then send full state to all
                socket.emit('stateChecksum', { checksum, ts: Date.now() });
                // Broadcast full state to everyone
                socket.emit('fullStateUpdate', { fullState: fs, checksum });
                showPopup('Resync Sent', 'Full state broadcasted to all players.', false);
            } catch (e) {
                console.error('Force resync failed:', e);
                showPopup('Resync Failed', e.message || 'Unknown error', true);
            }
        }

        // Chat socket handlers
        socket.on('chatMessage', (data) => {
            addMessage(data, false);
            if (document.hasFocus() === false || data.playerId !== loginState.myPlayerId) {
                // Play notify sound for incoming messages not from self
                playChatNotifySound();
            }
        });

        socket.on('typing', (data) => {
            if (data.playerId !== loginState.myPlayerId) {
                showTypingIndicator(data.playerId, data.isTyping);
            }
        });

        // Phase 5: Action application functions (called both locally and remotely)
        
        // Apply draw stock action for any player
        function applyDrawStockAction(playerSeat) {
            console.log(`Applying draw stock action for Player ${playerSeat}`);
            
            if (gameState.deck.length === 0) {
                console.log('Cannot draw - deck is empty');
                return;
            }
            
            // Draw card from deck
            const drawnCard = gameState.deck.pop();
            gameState.playerHands[playerSeat - 1].push(drawnCard);
            
            // Update game state
            gameState.stockCount = gameState.deck.length;
            gameState.hasDrawn = true;
            gameState.canPickUp = false;
            gameState.turnPhase = 'melding';
            
            // Update stock pile display
            const stockPile = document.getElementById('stock-pile');
            if (stockPile) {
                stockPile.textContent = gameState.stockCount > 0 ? gameState.stockCount : 'Empty';
                if (gameState.stockCount === 0) {
                    stockPile.style.cursor = 'default';
                }
            }
            
            // Update hand and check for biribaki distribution
            updatePlayerHand(playerSeat);
            
            // Update UI elements
            updateGameStatus();
            updateMeldButtonsState();
            updateDiscardAvailability();
            
            // Check for biribaki distribution after hand change
            maybeGiveBiribaki(playerSeat);
            
            console.log(`Player ${playerSeat} drew a card. Deck: ${gameState.stockCount} cards remaining`);
        }
        
        // Apply pick discard action for any player
        function applyPickDiscardAction(playerSeat) {
            console.log(`Applying pick discard action for Player ${playerSeat}`);
            
            if (gameState.discardPile.length === 0) {
                console.log('Cannot pick up - discard pile is empty');
                return;
            }
            
            // Pick up all cards from discard pile
            const pickedCards = [...gameState.discardPile];
            gameState.playerHands[playerSeat - 1].push(...pickedCards);
            
            // Clear discard pile
            gameState.discardPile = [];
            
            // Update game state
            gameState.hasDrawn = true;
            gameState.canPickUp = false;
            gameState.turnPhase = 'melding';
            
            // Update discard pile display
            updateDiscardDisplay();
            
            // Update hand and check for biribaki distribution
            updatePlayerHand(playerSeat);
            
            // Update UI elements
            updateGameStatus();
            updateMeldButtonsState();
            updateDiscardAvailability();
            
            // Check for biribaki distribution after hand change
            maybeGiveBiribaki(playerSeat);
            
            console.log(`Player ${playerSeat} picked up ${pickedCards.length} cards from discard pile`);
        }
        
        // Apply discard action for any player
        function applyDiscardAction(playerSeat, cardId) {
            console.log(`=== DISCARD ACTION DEBUG ===`);
            console.log(`Applying discard action for Player ${playerSeat}, cardId: ${cardId}`);
            console.log(`Current turn: ${gameState.currentTurn}, Current view: ${gameState.currentPlayerView}`);
            
            const playerHand = gameState.playerHands[playerSeat - 1];
            console.log(`Player ${playerSeat} hand size: ${playerHand.length}`);
            console.log(`Player ${playerSeat} hand card IDs:`, playerHand.map(card => card.id));
            
            const cardIndex = playerHand.findIndex(card => card.id === cardId);
            
            if (cardIndex === -1) {
                console.error(`DISCARD FAILED: Card ${cardId} not found in Player ${playerSeat}'s hand`);
                console.log(`Available card IDs in hand:`, playerHand.map(card => `${card.id} (${card.rank}${getSuitSymbol(card.suit)})`));
                return;
            }
            
            // Find the card element in the DOM for animation
            const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
            
            // Remove card from player's hand
            const discardedCard = playerHand.splice(cardIndex, 1)[0];
            console.log(`Successfully found and removed card: ${discardedCard.rank}${getSuitSymbol(discardedCard.suit)} (ID: ${discardedCard.id})`);
            
            // Animate card discard if element exists
            if (cardElement) {
                animateDiscard(cardElement, () => {
                    // Remove the card element after animation completes
                    cardElement.remove();
                });
            }
            
            // Add to discard pile
            gameState.discardPile.push(discardedCard);
            console.log(`Added card to discard pile. Discard pile size: ${gameState.discardPile.length}`);
            
            // Update game state - turn ends after discard
            gameState.hasDrawn = false;
            gameState.canPickUp = true;
            gameState.turnPhase = 'waiting';
            
            // Advance to next player's turn
            const oldTurn = gameState.currentTurn;
            advanceToNextTurn();
            console.log(`Turn advanced from Player ${oldTurn} to Player ${gameState.currentTurn}`);
            
            // Update discard pile display
            updateDiscardDisplay();
            
            // Update hand (but don't check biribaki distribution yet)
            updatePlayerHand(playerSeat);
            
            // Force update player name labels for all clients (critical for remote sync)
            updatePlayerNameLabels();
            
            // Force update turn display for all clients (critical for remote sync)
            updateTurnDisplay();
            
            // Update UI elements
            updateGameStatus();
            updateMeldButtonsState();
            updateDiscardAvailability();
            
            // Check for biribaki distribution AFTER all other updates are complete
            const biribakiResult = checkForBiribakiDistribution(playerSeat);
            
            console.log(`DISCARD ACTION COMPLETED: Player ${playerSeat} discarded ${discardedCard.rank}${getSuitSymbol(discardedCard.suit)}`);
            console.log(`=== END DISCARD ACTION DEBUG ===`);
            
            // Return the biribaki result so the calling function can handle the sync
            return biribakiResult;
        }
        
        // Phase 6: Apply meld creation action for remote players
        function applyMeldCreateAction(playerSeat, kind, cards) {
            console.log(`Applying meld create action for Player ${playerSeat}, kind: ${kind}, cards:`, cards);
            
            if (!cards || !Array.isArray(cards) || cards.length === 0) {
                console.error('Invalid cards array for meld creation:', cards);
                return;
            }
            
            // Convert string card IDs back to card objects
            const cardObjects = cards.map(cardString => stringToCard(cardString)).filter(card => card !== null);
            
            if (cardObjects.length === 0) {
                console.error('No valid card objects created from strings:', cards);
                return;
            }
            
            console.log(`Converted ${cards.length} card strings to ${cardObjects.length} card objects`);
            
            // Remove cards from the remote player's hand
            const remotePlayerHand = gameState.playerHands[playerSeat - 1];
            cardObjects.forEach(cardObj => {
                // Find and remove a matching card from the remote player's hand
                // Since remote cards have network IDs, we match by rank and suit
                const matchIndex = remotePlayerHand.findIndex(handCard => 
                    handCard.rank === cardObj.rank && handCard.suit === cardObj.suit
                );
                
                if (matchIndex !== -1) {
                    remotePlayerHand.splice(matchIndex, 1);
                    console.log(`Removed ${cardObj.rank}${getSuitSymbol(cardObj.suit)} from Player ${playerSeat}'s hand`);
                } else {
                    console.warn(`Could not find matching card ${cardObj.rank}${getSuitSymbol(cardObj.suit)} in Player ${playerSeat}'s hand`);
                }
            });
            
            // Create the meld based on kind
            let meldResult;
            if (kind === 'set') {
                meldResult = tryCreateSet(cardObjects);
            } else if (kind === 'run') {
                meldResult = tryCreateRun(cardObjects);
            } else {
                console.error('Unknown meld kind:', kind);
                return;
            }
            
            if (!meldResult || !meldResult.valid) {
                console.error('Failed to create valid meld from remote action:', meldResult);
                return;
            }
            
            // Determine which meld area to use based on the remote player's team
            const remotePlayerTeam = getPlayerTeam(playerSeat);
            let targetMeldArea;
            
            if (remotePlayerTeam === 1) {
                // Team 1 (Players 1&3) use player1 area
                targetMeldArea = document.querySelector('.meld-area.player1');
            } else {
                // Team 2 (Players 2&4) use player2 area
                targetMeldArea = document.querySelector('.meld-area.player2');
            }
            
            if (!targetMeldArea) {
                console.error('Could not find target meld area for team:', remotePlayerTeam);
                return;
            }
            
            // Set up the area for melds if this is the first meld
            if (targetMeldArea.children.length === 0) {
                targetMeldArea.style.flexDirection = 'row';
                targetMeldArea.style.alignItems = 'flex-start';
                targetMeldArea.style.justifyContent = 'flex-start';
                targetMeldArea.style.padding = '15px';
                targetMeldArea.style.flexWrap = 'wrap';
                targetMeldArea.style.gap = '10px';
            }
            
            // Store meld data with remote player ownership
            const meldId = `meld_${Date.now()}_${Math.random()}_remote_${playerSeat}`;
            const meldData = {
                id: meldId,
                type: kind,
                data: meldResult,
                ownerPlayer: playerSeat // Track which remote player created this meld
            };
            gameState.playerMelds.push(meldData);
            
            // Create meld display container
            const meldDisplay = document.createElement('div');
            meldDisplay.className = 'run-display'; // Reuse run display styles for both sets and runs
            meldDisplay.dataset.meldId = meldId;
            
            // Reduce height for BIRIBA melds (7+ cards)
            if (meldResult.length >= 7) {
                meldDisplay.style.minHeight = '90px';
                meldDisplay.style.paddingBottom = '0px';
            }
            
            // Add meld info - show c/d + accurate score
            const meldInfo = document.createElement('div');
            meldInfo.className = 'run-info';
            const status = meldResult.isClean ? 'c' : 'd';
            const scoreData = calculateMeldScore(meldResult, kind);
            meldInfo.textContent = `${status} + ${scoreData.totalScore}`;
            meldDisplay.appendChild(meldInfo);
            
            // Create cards stack container
            const cardsStack = document.createElement('div');
            cardsStack.className = 'run-cards-stack';
            
            // Use cards in their original order
            const sortedCards = [...meldResult.cards];
            
            // Add cards to stack with proper positioning
            sortedCards.forEach((card, index) => {
                const meldCard = document.createElement('div');
                meldCard.className = `run-card ${card.suit}`;
                
                // Position cards with increased offset (match ~55% size bump)
                const topOffset = index * (window.innerWidth <= 768 ? 30 : 26);
                const zIndex = sortedCards.length - index;
                
                meldCard.style.top = `${topOffset}px`;
                meldCard.style.zIndex = zIndex;
                
                // Check if this is the last card (bottom of stack)
                const isLastCard = index === sortedCards.length - 1;
                const isBiriba = sortedCards.length >= 7;
                
                // Add margin-top to all cards to move them closer to description
                meldCard.style.marginTop = '-20px';
                
                // Make last card just a tiny bit bigger and position it lower
                if (isLastCard) {
                    meldCard.style.width = '78px';
                    meldCard.style.height = '116px';
                    
                    // Special handling for BIRIBA melds (7+ cards)
                    if (isBiriba) {
                        // Rotate the last card horizontally and center it properly
                        meldCard.style.transform = 'translateX(-50%) rotate(90deg)';
                        meldCard.style.transformOrigin = 'center';
                        // Position and margin for horizontal last card
                        meldCard.style.top = `${topOffset + (window.innerWidth <= 768 ? 16 : 24)}px`;
                        meldCard.style.marginTop = '-19px';
                    } else {
                        // For non-BIRIBA melds, keep the normal centering transform and positioning (scaled)
                        meldCard.style.top = `${topOffset + (window.innerWidth <= 768 ? 1 : 13)}px`;
                        meldCard.style.marginTop = '9px';
                    }
                } else {
                    meldCard.style.width = '78px';
                    meldCard.style.height = '113px';
                }
                
                // Use background image for card display
                if (card.imagePath) {
                    let imagePath;
                    if (isLastCard) {
                        // Use full card image for last card
                        imagePath = card.imagePath;
                    } else {
                        // Use cropped version for all other cards
                        imagePath = card.imagePath.replace('.png', '_cropped.png');
                    }
                    
                    meldCard.style.backgroundImage = `url("${imagePath}")`;
                    meldCard.style.backgroundSize = 'contain';
                    meldCard.style.backgroundPosition = 'center';
                    meldCard.style.backgroundRepeat = 'no-repeat';
                } else {
                    // Fallback to text display
                    if (card.suit === 'joker') {
                        meldCard.textContent = 'JOKER';
                    } else {
                        const suitSymbol = getSuitSymbol(card.suit);
                        meldCard.textContent = card.rank + suitSymbol;
                    }
                }
                
                cardsStack.appendChild(meldCard);
            });
            
            // Set the height of the stack container based on number of cards
            let stackHeight = (window.innerWidth <= 768 ? 98 : 130) + (sortedCards.length - 1) * (window.innerWidth <= 768 ? 18 : 26);
            
            // Reduce height by 20px for BIRIBA melds (7+ cards)
            if (sortedCards.length >= 7) {
                stackHeight -= 30;
            }
            
            cardsStack.style.height = `${stackHeight}px`;
            
            meldDisplay.appendChild(cardsStack);
            targetMeldArea.appendChild(meldDisplay);
            
            // Update player name labels to reflect new card counts
            updatePlayerNameLabels();
            
            // Update team score display
            updateTeamScoreDisplay();
            
            // Check for biribaki distribution after hand change
            const biribakiResult = checkForBiribakiDistribution(playerSeat);
            
            console.log(`Successfully applied ${kind} meld creation for Player ${playerSeat} (Team ${remotePlayerTeam})`);
            
            // Return the biribaki result so the calling function can handle the sync
            return biribakiResult;
        }
        
        // Apply dev seven card run action (for remote clients)
        function applyDevSevenCardRunAction(playerSeat, newHand) {
            console.log(`Applying dev seven card run action for Player ${playerSeat}`);
            
            if (!newHand || !Array.isArray(newHand) || newHand.length === 0) {
                console.error('Invalid newHand array for dev seven card run:', newHand);
                return;
            }
            
            // Convert the hand data back to full card objects with image paths
            const fullHand = newHand.map(card => ({
                suit: card.suit,
                rank: card.rank,
                id: card.id,
                imagePath: `cards/${getImageName(card.rank, card.suit, 0)}`
            }));
            
            // Update the remote player's hand
            gameState.playerHands[playerSeat - 1] = [...fullHand];
            
            // Update current view if this is the viewed player
            if (playerSeat === gameState.currentPlayerView) {
                gameState.playerHand = gameState.playerHands[playerSeat - 1];
            }
            
            // Set turn state to allow discarding (same as after drawing a card)
            gameState.hasDrawn = true;
            gameState.turnPhase = 'melding';
            
            // Update displays
            updatePlayerNameLabels();
            updateTurnDisplay();
            updateGameStatus();
            updateMeldButtonsState();
            updateDiscardAvailability();
            
            // Re-render hand if this is the current view
            if (playerSeat === gameState.currentPlayerView) {
                renderHand();
            }
            
            console.log(`Successfully applied dev seven card run for Player ${playerSeat}`);
        }
        
        // Apply biribaki preview action (for remote clients)
        function applyBiribakiPreviewAction(playerId, team) {
            console.log(`=== BIRIBAKI PREVIEW DEBUG ===`);
            console.log(`Applying biribaki preview action for Player ${playerId}, Team ${team}`);
            console.log(`Current player view: ${gameState.currentPlayerView}`);
            console.log(`My player ID: ${loginState.myPlayerId}`);
            console.log(`Before preview - Player ${playerId} hand size: ${gameState.playerHands[playerId - 1].length}`);
            console.log(`Before preview - Current view hand size: ${gameState.playerHands[gameState.currentPlayerView - 1].length}`);
            
            // Call the biribaki checker for the specified player
            biribakiCardChecker(playerId);
            
            console.log(`After preview - Player ${playerId} hand size: ${gameState.playerHands[playerId - 1].length}`);
            console.log(`After preview - Current view hand size: ${gameState.playerHands[gameState.currentPlayerView - 1].length}`);
            console.log(`=== END BIRIBAKI PREVIEW DEBUG ===`);
        }
        
        // Apply skip turn action (for remote clients)
        function applySkipTurnAction(playerId) {
            console.log(`Applying skip turn action for Player ${playerId}`);
            
            // Advance to next player's turn
            const oldTurn = gameState.currentTurn;
            advanceToNextTurn();
            console.log(`Turn advanced from Player ${oldTurn} to Player ${gameState.currentTurn}`);
            
            // Reset turn state
            gameState.hasDrawn = false;
            gameState.canPickUp = true;
            gameState.turnPhase = 'waiting';
            
            // Update displays
            updatePlayerNameLabels();
            updateTurnDisplay();
            updateGameStatus();
            updateMeldButtonsState();
            updateDiscardAvailability();
            
            console.log(`Successfully applied skip turn for Player ${playerId}`);
        }
        
        // Stub function for biribaki distribution check (Phase 5)
        function maybeGiveBiribaki(playerSeat) {
            // This function will be implemented in future phases
            // For now, it's a stub that does nothing
            console.log(`Checking biribaki distribution for Player ${playerSeat} (stub)`);
        }
        
        // Game state
        let gameState = {
            deck: [],
            playerHands: [[], [], [], []], // Hands for all 4 players [Player1, Player2, Player3, Player4]
            playerHand: [], // Alias for playerHands[0] (Player 1) for backward compatibility
            discardPile: [],
            stockCount: 108, // 2 decks + 4 jokers
            selectedCards: [],
            hasDrawn: false, // Track if player has drawn this turn
            canPickUp: true, // Track if player can pick up from discard
            sortMode: 'rank', // Track current sort mode: 'rank' or 'suit'
            extendMeldMode: false, // Track if we're in extend meld mode
            playerMelds: [], // Store player's melds for extension
            turnPhase: 'waiting', // Track turn phase: 'waiting' (need to draw), 'melding' (can create melds)
            atouSuit: null, // Trump suit determined by first flipped card or first player's choice if joker
            atouPending: false, // Whether atou needs to be chosen (when first card is joker)
            totalScore: 0, // Player's total score
            currentPlayerView: 1, // Track which player's perspective we're viewing (1-4)
            currentTurn: 1, // Which player's turn it is (1-4)
            turnOrder: [1, 2, 3, 4], // Turn rotation order
            teamBiribakia: { 1: [], 2: [] }, // Team biribakia: Team 1 (Players 1&3), Team 2 (Players 2&4)
            teamBiribakiReceived: { 1: 0, 2: 0 }, // Track how many times each team has received their biribaki
            randomStartingPlayerSkips: 0, // Number of turns to skip at game start (0-3)
            disableSets: false, // Whether sets are disabled in the game
            runBaseValue: 2000, // Base value for 13-card runs (1000 or 2000)
            atouBiribaValue: 400 // Value of atou biribas (400 or 600)
        };

        // Convert card object to string ID for network transmission
        function cardToString(card) {
            if (!card || !card.suit || !card.rank) {
                console.error('Invalid card for conversion:', card);
                return null;
            }
            
            if (card.suit === 'joker') {
                return 'JOKER';
            }
            
            return `${card.rank}_${card.suit}`;
        }

        // Convert string ID back to card object (for receiving from network)
        function stringToCard(cardString) {
            if (!cardString) return null;
            
            if (cardString === 'JOKER') {
                return {
                    suit: 'joker',
                    rank: 'JOKER',
                    id: `joker_network_${cardString}`, // Use deterministic ID for network cards
                    imagePath: 'cards/red_joker.png' // Default to red joker
                };
            }
            
            const parts = cardString.split('_');
            if (parts.length !== 2) {
                console.error('Invalid card string format:', cardString);
                return null;
            }
            
            const [rank, suit] = parts;
            const imageName = getImageName(rank, suit, 0); // Use first deck by default
            
            return {
                suit: suit,
                rank: rank,
                id: `network_${cardString}`, // Use deterministic ID based on card string
                imagePath: `cards/${imageName}`
            };
        }

        // Convert current gameState to target fullState format for network transmission
        function gameStateToFullState() {
            // Convert playerHands array to hands object with string IDs (sorted for consistent checksums)
            const hands = {};
            for (let i = 0; i < 4; i++) {
                const playerNumber = i + 1;
                const cardStrings = gameState.playerHands[i].map(card => cardToString(card)).filter(id => id !== null);
                // Sort card strings to ensure consistent checksums regardless of local sort order
                hands[playerNumber] = cardStrings.sort();
            }
            
            // Convert discardPile array to discard object with string IDs
            let discard;
            if (gameState.discardPile.length === 0) {
                discard = { top: null, history: [] };
            } else {
                const history = gameState.discardPile.slice(0, -1).map(card => cardToString(card)).filter(id => id !== null).sort();
                const top = cardToString(gameState.discardPile[gameState.discardPile.length - 1]);
                discard = { top: top, history: history };
            }
            
            // Convert deck to string IDs (sorted for consistent checksums)
            const deck = gameState.deck.map(card => cardToString(card)).filter(id => id !== null).sort();
            
            // Convert turnPhase to phase
            let phase;
            if (gameState.turnPhase === 'waiting') {
                phase = 'draw';
            } else if (gameState.turnPhase === 'melding') {
                phase = 'meld';
            } else {
                phase = 'discard'; // Default fallback
            }
            
            // Convert atouSuit to atou (string ID format)
            let atou = null;
            if (gameState.atouSuit && gameState.atouSuit !== 'joker') {
                atou = gameState.atouSuit;
            }
            
            // Convert playerMelds to melds array (simplified for now)
            const melds = gameState.playerMelds.map(meldData => ({
                id: meldData.id,
                type: meldData.type,
                owner: meldData.ownerPlayer,
                cards: meldData.data.cards.map(card => cardToString(card)).filter(id => id !== null).sort()
            }));
            
            // Calculate team scores
            const teamScores = calculateTeamScores();
            const scores = {
                team1: teamScores[1],
                team2: teamScores[2]
            };
            
            // Convert teamBiribakiReceived to biribaki format and include piles for sync
            const biribaki = {
                team1: { received: gameState.teamBiribakiReceived[1] },
                team2: { received: gameState.teamBiribakiReceived[2] },
                piles: {
                    1: (gameState.teamBiribakia[1] || []).map(card => cardToString(card)).filter(id => id !== null).sort(),
                    2: (gameState.teamBiribakia[2] || []).map(card => cardToString(card)).filter(id => id !== null).sort()
                }
            };
            
            return {
                deck: deck,
                hands: hands,
                discard: discard,
                atou: atou,
                turn: gameState.currentTurn,
                turnOrder: gameState.turnOrder,
                phase: phase,
                melds: melds,
                scores: scores,
                biribaki: biribaki,
                randomStartingPlayerSkips: gameState.randomStartingPlayerSkips,
                runBaseValue: gameState.runBaseValue,
                disableSets: gameState.disableSets,
                atouBiribaValue: gameState.atouBiribaValue
            };
        }

        // Apply fullState from network to current gameState
        function applyFullState(fullState) {
            console.log('Applying fullState:', fullState);
            
            try {
                // Convert deck from string IDs to card objects
                gameState.deck = fullState.deck.map(cardString => stringToCard(cardString)).filter(card => card !== null);
                
                // Convert hands object to playerHands array
                gameState.playerHands = [[], [], [], []];
                for (let playerNumber = 1; playerNumber <= 4; playerNumber++) {
                    if (fullState.hands[playerNumber]) {
                        gameState.playerHands[playerNumber - 1] = fullState.hands[playerNumber]
                            .map(cardString => stringToCard(cardString))
                            .filter(card => card !== null);
                    }
                }
                
                // Reconstruct joinedPlayers Set based on which players have cards
                joinedPlayers.clear();
                for (let playerNumber = 1; playerNumber <= 4; playerNumber++) {
                    if (gameState.playerHands[playerNumber - 1].length > 0) {
                        joinedPlayers.add(playerNumber);
                    }
                }
                console.log(`Reconstructed joinedPlayers from fullState: ${Array.from(joinedPlayers).join(', ')}`);
                
                // Update backward compatibility reference
                gameState.playerHand = gameState.playerHands[gameState.currentPlayerView - 1];
                
                // Clear selected cards to prevent ID mismatch issues after sync
                gameState.selectedCards = [];
                
                // Convert discard object to discardPile array
                gameState.discardPile = [];
                if (fullState.discard.history) {
                    gameState.discardPile.push(...fullState.discard.history
                        .map(cardString => stringToCard(cardString))
                        .filter(card => card !== null));
                }
                if (fullState.discard.top) {
                    const topCard = stringToCard(fullState.discard.top);
                    if (topCard) {
                        gameState.discardPile.push(topCard);
                    }
                }
                
                // Convert phase to turnPhase
                if (fullState.phase === 'draw') {
                    gameState.turnPhase = 'waiting';
                    gameState.hasDrawn = false;
                    gameState.canPickUp = true;
                } else if (fullState.phase === 'meld') {
                    gameState.turnPhase = 'melding';
                    gameState.hasDrawn = true;
                    gameState.canPickUp = false;
                } else if (fullState.phase === 'discard') {
                    gameState.turnPhase = 'melding'; // Allow discarding
                    gameState.hasDrawn = true;
                    gameState.canPickUp = false;
                }
                
                // Convert atou to atouSuit
                gameState.atouSuit = fullState.atou;
                updateAtouIndicator();
                
                // Update turn
                gameState.currentTurn = fullState.turn;
                
                // Update turn order
                if (fullState.turnOrder) {
                    gameState.turnOrder = fullState.turnOrder;
                    console.log(`Applied turnOrder from fullState: ${gameState.turnOrder.join(', ')}`);
                } else {
                    // Fallback: reconstruct turn order from joined players
                    gameState.turnOrder = Array.from(joinedPlayers).sort();
                    console.log(`Reconstructed turnOrder from joinedPlayers: ${gameState.turnOrder.join(', ')}`);
                }
                
                // Update random starting player skips
                if (fullState.randomStartingPlayerSkips !== undefined) {
                    gameState.randomStartingPlayerSkips = fullState.randomStartingPlayerSkips;
                    console.log(`Applied randomStartingPlayerSkips from fullState: ${gameState.randomStartingPlayerSkips}`);
                    
                    // Apply the random skips if this is a game start
                    if (gameState.randomStartingPlayerSkips > 0) {
                        console.log(`Applying ${gameState.randomStartingPlayerSkips} random starting player skips from fullState`);
                        for (let i = 0; i < gameState.randomStartingPlayerSkips; i++) {
                            advanceToNextTurn();
                        }
                        console.log(`Random starting player set to: Player ${gameState.currentTurn}`);
                    }
                }
                
                // Update disable sets setting
                if (fullState.disableSets !== undefined) {
                    gameState.disableSets = fullState.disableSets;
                    console.log(`Applied disableSets from fullState: ${gameState.disableSets}`);
                    updateCreateSetButtonVisibility();
                }
                
                // Update atou biriba value setting
                if (fullState.atouBiribaValue !== undefined) {
                    gameState.atouBiribaValue = fullState.atouBiribaValue;
                    console.log(`Applied atouBiribaValue from fullState: ${gameState.atouBiribaValue}`);
                }
                
                // Update run base value setting
                if (fullState.runBaseValue !== undefined) {
                    gameState.runBaseValue = fullState.runBaseValue;
                    console.log(`Applied runBaseValue from fullState: ${gameState.runBaseValue}`);
                    updateRunBaseValueDisplay();                    updateAtouValueDisplay();
            updateRunBaseValueDisplay();
                }
                
                // Convert melds and render them visually
                gameState.playerMelds = [];
                
                // Clear existing meld displays first
                const player1Area = document.querySelector('.meld-area.player1');
                const player2Area = document.querySelector('.meld-area.player2');
                if (player1Area) {
                    player1Area.innerHTML = '';
                    player1Area.style.flexDirection = '';
                }
                if (player2Area) {
                    player2Area.innerHTML = '';
                    player2Area.style.flexDirection = '';
                }
                
                if (fullState.melds) {
                    fullState.melds.forEach(meldData => {
                        const cards = meldData.cards.map(cardString => stringToCard(cardString)).filter(card => card !== null);
                        
                        if (cards.length === 0) {
                            console.warn('No valid cards found for meld:', meldData);
                            return;
                        }
                        
                        // Reconstruct meld data structure
                        const reconstructedMeld = {
                            id: meldData.id,
                            type: meldData.type,
                            ownerPlayer: meldData.owner,
                            data: {
                                cards: cards,
                                length: cards.length,
                                isClean: true, // Simplified for now - could be enhanced later
                                isBiriba: cards.length >= 7
                            }
                        };
                        
                        gameState.playerMelds.push(reconstructedMeld);
                        
                        // Render the meld visually
                        renderMeldFromFullState(reconstructedMeld);
                    });
                }
                
                // Convert biribaki format to teamBiribakiReceived and restore piles
                if (fullState.biribaki) {
                    gameState.teamBiribakiReceived[1] = fullState.biribaki.team1.received || 0;
                    gameState.teamBiribakiReceived[2] = fullState.biribaki.team2.received || 0;
                    if (fullState.biribaki.piles) {
                        gameState.teamBiribakia[1] = (fullState.biribaki.piles[1] || []).map(stringToCard).filter(card => card !== null);
                        gameState.teamBiribakia[2] = (fullState.biribaki.piles[2] || []).map(stringToCard).filter(card => card !== null);
                    }
                }
                
                // Update stock count
                gameState.stockCount = gameState.deck.length;
                
                // Update UI elements
                updateDiscardDisplay();
                updatePlayerNameLabels();
                updateTurnDisplay();
                updateMeldButtonsState();
                updateDiscardAvailability();
                updateTeamScoreDisplay();
                renderHand();
                
                // Update stock pile display
                const stockPile = document.getElementById('stock-pile');
                if (stockPile) {
                    stockPile.textContent = gameState.stockCount > 0 ? gameState.stockCount : 'Empty';
                }
                
                console.log('FullState applied successfully');
                
            } catch (error) {
                console.error('Error applying fullState:', error);
                console.error('FullState data:', fullState);
            }
        }

        // Compute a fast, stable checksum for a fullState object
        function computeFullStateChecksum(fullState) {
            // Build a deterministic string by ordering keys and arrays
            const normalize = (obj) => {
                if (obj === null || obj === undefined) return 'null';
                if (Array.isArray(obj)) return '[' + obj.map(normalize).join(',') + ']';
                if (typeof obj === 'object') {
                    const keys = Object.keys(obj).sort();
                    return '{' + keys.map(k => k + ':' + normalize(obj[k])).join(',') + '}';
                }
                return String(obj);
            };
            const data = normalize(fullState);
            // Simple DJB2 hash
            let hash = 5381;
            for (let i = 0; i < data.length; i++) {
                hash = ((hash << 5) + hash) + data.charCodeAt(i);
                hash = hash >>> 0;
            }
            return hash.toString(36);
        }

        // Render a meld visually from fullState reconstruction
        function renderMeldFromFullState(meldData) {
            console.log('Rendering meld from fullState:', meldData);
            
            if (!meldData || !meldData.data || !meldData.ownerPlayer) {
                console.error('Invalid meld data for rendering:', meldData);
                return;
            }
            
            // Determine which meld area to use based on the meld owner's team
            const ownerPlayerTeam = getPlayerTeam(meldData.ownerPlayer);
            let targetMeldArea;
            
            if (ownerPlayerTeam === 1) {
                // Team 1 (Players 1&3) use player1 area
                targetMeldArea = document.querySelector('.meld-area.player1');
            } else {
                // Team 2 (Players 2&4) use player2 area
                targetMeldArea = document.querySelector('.meld-area.player2');
            }
            
            if (!targetMeldArea) {
                console.error('Could not find target meld area for team:', ownerPlayerTeam);
                return;
            }
            
            // Set up the area for melds if this is the first meld
            if (targetMeldArea.children.length === 0) {
                targetMeldArea.style.flexDirection = 'row';
                targetMeldArea.style.alignItems = 'flex-start';
                targetMeldArea.style.justifyContent = 'flex-start';
                targetMeldArea.style.padding = '15px';
                targetMeldArea.style.flexWrap = 'wrap';
                targetMeldArea.style.gap = '10px';
            }
            
            // Create meld display container
            const meldDisplay = document.createElement('div');
            meldDisplay.className = 'run-display'; // Reuse run display styles for both sets and runs
            meldDisplay.dataset.meldId = meldData.id;
            
            // Reduce height for BIRIBA melds (7+ cards)
            if (meldData.data.length >= 7) {
                meldDisplay.style.minHeight = '90px';
                meldDisplay.style.paddingBottom = '0px';
            }
            
            // Add meld info - show c/d + accurate score
            const meldInfo = document.createElement('div');
            meldInfo.className = 'run-info';
            const status = meldData.data.isClean ? 'c' : 'd';
            const scoreData = calculateMeldScore(meldData.data, meldData.type);
            meldInfo.textContent = `${status} + ${scoreData.totalScore}`;
            meldDisplay.appendChild(meldInfo);
            
            // Create cards stack container
            const cardsStack = document.createElement('div');
            cardsStack.className = 'run-cards-stack';
            
            // Order cards based on meld type for remote-rendered melds
            let sortedCards;
            if (meldData.type === 'run') {
                sortedCards = orderRunCardsForDisplay(meldData.data);
            } else if (meldData.type === 'set') {
                sortedCards = orderSetCardsForDisplay(meldData.data);
            } else {
                sortedCards = [...meldData.data.cards];
            }
            
            // Add cards to stack with proper positioning
            sortedCards.forEach((card, index) => {
                const meldCard = document.createElement('div');
                meldCard.className = `run-card ${card.suit}`;
                
                // Position cards with increased offset (match ~55% size bump)
                const topOffset = index * 26;
                const zIndex = sortedCards.length - index;
                
                meldCard.style.top = `${topOffset}px`;
                meldCard.style.zIndex = zIndex;
                
                // Check if this is the last card (bottom of stack)
                const isLastCard = index === sortedCards.length - 1;
                const isBiriba = sortedCards.length >= 7;
                
                // Add margin-top to all cards to move them closer to description
                meldCard.style.marginTop = '-20px';
                
                // Make last card just a tiny bit bigger and position it lower
                if (isLastCard) {
                    meldCard.style.width = '68px';
                    meldCard.style.height = '97px';
                    
                    // Special handling for BIRIBA melds (7+ cards)
                    if (isBiriba) {
                        // Rotate the last card horizontally and center it properly
                        meldCard.style.transform = 'translateX(-50%) rotate(90deg)';
                        meldCard.style.transformOrigin = 'center';
                        // Position and margin for horizontal last card
                        meldCard.style.top = `${topOffset + (window.innerWidth <= 768 ? 16 : 24)}px`;
                        meldCard.style.marginTop = '-19px';
                    } else {
                        // For non-BIRIBA melds, keep the normal centering transform and positioning (scaled)
                        meldCard.style.top = `${topOffset + (window.innerWidth <= 768 ? 1 : 13)}px`;
                        meldCard.style.marginTop = '9px';
                    }
                } else {
                    meldCard.style.width = '68px';
                    meldCard.style.height = '94px';
                }
                
                // Use background image for card display
                if (card.imagePath) {
                    let imagePath;
                    if (isLastCard) {
                        // Use full card image for last card
                        imagePath = card.imagePath;
                    } else {
                        // Use cropped version for all other cards
                        imagePath = card.imagePath.replace('.png', '_cropped.png');
                    }
                    
                    meldCard.style.backgroundImage = `url("${imagePath}")`;
                    meldCard.style.backgroundSize = 'contain';
                    meldCard.style.backgroundPosition = 'center';
                    meldCard.style.backgroundRepeat = 'no-repeat';
                } else {
                    // Fallback to text display
                    if (card.suit === 'joker') {
                        meldCard.textContent = 'JOKER';
                    } else {
                        const suitSymbol = getSuitSymbol(card.suit);
                        meldCard.textContent = card.rank + suitSymbol;
                    }
                }
                
                cardsStack.appendChild(meldCard);
            });
            
            // Set the height of the stack container based on number of cards
            let stackHeight = 130 + (sortedCards.length - 1) * 26;
            
            // Reduce height by 20px for BIRIBA melds (7+ cards)
            if (sortedCards.length >= 7) {
                stackHeight -= 30;
            }
            
            cardsStack.style.height = `${stackHeight}px`;
            
            meldDisplay.appendChild(cardsStack);
            targetMeldArea.appendChild(meldDisplay);
            
            console.log(`Successfully rendered ${meldData.type} meld for Player ${meldData.ownerPlayer} (Team ${ownerPlayerTeam})`);
        }

        // Test function to demonstrate fullState conversion
        function testFullStateConversion() {
            console.log('=== Testing FullState Conversion ===');
            
            // Get current state as fullState
            const fullState = gameStateToFullState();
            console.log('Current gameState converted to fullState:', fullState);
            
            // Test the reverse conversion
            console.log('Testing applyFullState...');
            applyFullState(fullState);
            
            console.log('FullState conversion test completed');
        }

        // Advance to the next player's turn
        function advanceToNextTurn() {
            // Find current player index in turn order
            const currentIndex = gameState.turnOrder.indexOf(gameState.currentTurn);
            
            if (currentIndex === -1) {
                // Current turn player is not in turn order (they left), find first available player
                console.log(`Current turn player ${gameState.currentTurn} is not in turn order, finding next available player`);
                if (gameState.turnOrder.length > 0) {
                    gameState.currentTurn = gameState.turnOrder[0];
                } else {
                    console.log('No players in turn order - cannot advance turn');
                    return;
                }
            } else {
            // Move to next player (wrap around to 0 if at end)
            const nextIndex = (currentIndex + 1) % gameState.turnOrder.length;
            gameState.currentTurn = gameState.turnOrder[nextIndex];
            }
            
            // Update turn display
            updateTurnDisplay();
            
            console.log(`Turn advanced to Player ${gameState.currentTurn}`);
            
            // Check if the new turn player slot is empty and auto-skip if needed
            setTimeout(() => {
                checkAndSkipEmptyPlayerTurn();
            }, 100);
        }

        // Update turn display to show which player's turn it is
        function updateTurnDisplay() {
            // Remove current-turn class from all player name labels
            document.querySelectorAll('.player-name-label').forEach(label => {
                label.classList.remove('current-turn');
            });
            
            // Add current-turn class to the appropriate player label based on current perspective
            const currentPlayer = gameState.currentPlayerView;
            const currentTurnPlayer = gameState.currentTurn;
            
            // Define the player positions for each perspective
            const perspectives = {
                1: { bottom: 1, right: 2, top: 3, left: 4 },
                2: { bottom: 2, right: 3, top: 4, left: 1 },
                3: { bottom: 3, right: 4, top: 1, left: 2 },
                4: { bottom: 4, right: 1, top: 2, left: 3 }
            };
            
            const layout = perspectives[currentPlayer];
            
            // Find which position the current turn player is in for this perspective
            let positionForCurrentTurn = null;
            if (layout.bottom === currentTurnPlayer) positionForCurrentTurn = 'bottom';
            else if (layout.right === currentTurnPlayer) positionForCurrentTurn = 'right';
            else if (layout.top === currentTurnPlayer) positionForCurrentTurn = 'top';
            else if (layout.left === currentTurnPlayer) positionForCurrentTurn = 'left';
            
            // Add glow effect to the appropriate label
            if (positionForCurrentTurn) {
                const labelElement = document.getElementById(`player-name-${positionForCurrentTurn}`);
                if (labelElement) {
                    labelElement.classList.add('current-turn');
                }
            }
            
            // Add golden glow to game table when it's your turn
            const gameTable = document.querySelector('.game-table');
            if (gameTable) {
                if (gameState.currentTurn === loginState.myPlayerId) {
                    gameTable.classList.add('your-turn');
                    console.log('Added turn glow - it\'s your turn!');
                    // Play a subtle sound cue when it's your turn
                    playYourTurnSound();
                } else {
                    gameTable.classList.remove('your-turn');
                    console.log('Removed turn glow - not your turn');
                }
            }
            
            // Note: Auto-skip check removed from updateTurnDisplay to prevent infinite loops
        }

        // Card suits and ranks
        const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        // BIRIBA Scoring System
        function getCardPoints(card) {
            if (card.rank === 'JOKER') return 30;
            if (card.rank === '2') return 20;
            if (card.rank === 'A') return 15;
            if (['K', 'Q', 'J', '10', '9', '8'].includes(card.rank)) return 10;
            if (['7', '6', '5', '4', '3'].includes(card.rank)) return 5;
            return 0;
        }

        // Calculate meld score with bonuses
        function calculateMeldScore(meld, meldType) {
            let baseScore = 0;
            let bonuses = 0;
            
            // Calculate base card points
            meld.cards.forEach(card => {
                baseScore += getCardPoints(card);
            });
            
            // Biriba values (7+ cards)
            if (meld.length >= 7) {
                    if (gameState.atouSuit && meld.suit === gameState.atouSuit) {
                    // Atou biriba - use configurable value
                    if (meld.isClean) {
                        bonuses += gameState.atouBiribaValue; // Clean atou biriba
                    } else {
                        bonuses += Math.floor(gameState.atouBiribaValue / 2); // Dirty atou biriba
                    }
                } else {
                    // Non-atou biriba - use standard values
                    if (meld.isClean) {
                        bonuses += 200; // Clean non-atou biriba
                    } else {
                        bonuses += 100; // Dirty non-atou biriba
                    }
                }
            }            
            // 13-card run values (Ace through King)
            if (meldType === 'run' && meld.length === 13) {
                    if (gameState.atouSuit && meld.suit === gameState.atouSuit) {
                    // Atou 13-card run - use configurable atou value
                    if (meld.isClean) {
                        bonuses += gameState.atouBiribaValue; // Clean atou 13-card run
                    } else {
                        bonuses += Math.floor(gameState.atouBiribaValue / 2); // Dirty atou 13-card run
                    }
                } else {
                    // Non-atou 13-card run - use configurable base value
                    if (meld.isClean) {
                        bonuses += gameState.runBaseValue; // Clean non-atou 13-card run
                    } else {
                        bonuses += Math.floor(gameState.runBaseValue / 2); // Dirty non-atou 13-card run
                    }
                }
            }            
            return {
                baseScore: baseScore,
                bonuses: bonuses,
                totalScore: baseScore + bonuses
            };
        }

        // Update total score
        function updateTotalScore() {
            let totalScore = 0;
            
            gameState.playerMelds.forEach(meldData => {
                const scoreData = calculateMeldScore(meldData.data, meldData.type);
                totalScore += scoreData.totalScore;
            });
            
            gameState.totalScore = totalScore;
            updateScoreDisplay();
        }

        // Calculate team scores from all player melds
        function calculateTeamScores() {
            const teamScores = { 1: 0, 2: 0 };
            
            // Iterate through all player melds and sum scores by team
            gameState.playerMelds.forEach(meldData => {
                if (meldData && meldData.data && meldData.ownerPlayer) {
                    const playerTeam = getPlayerTeam(meldData.ownerPlayer);
                    const scoreData = calculateMeldScore(meldData.data, meldData.type);
                    teamScores[playerTeam] += scoreData.totalScore;
                }
            });
            
            return teamScores;
        }

        // Update team score display in the UI
        function updateTeamScoreDisplay() {
            const teamScores = calculateTeamScores();
            
            // Update the DOM elements
            const team1ScoreElement = document.getElementById('team1-score');
            const team2ScoreElement = document.getElementById('team2-score');
            const team1Dots = document.querySelectorAll('#team1-biribaki-dots .biribaki-dot');
            const team2Dots = document.querySelectorAll('#team2-biribaki-dots .biribaki-dot');
            const team1Deck = document.getElementById('team1-biribaki-deck');
            const team2Deck = document.getElementById('team2-biribaki-deck');
            
            if (team1ScoreElement) {
                team1ScoreElement.textContent = teamScores[1];
            }
            if (team2ScoreElement) {
                team2ScoreElement.textContent = teamScores[2];
            }
            // Update biribaki dots (0, 1, 2)
            const r1 = Math.min(gameState.teamBiribakiReceived[1] || 0, 2);
            const r2 = Math.min(gameState.teamBiribakiReceived[2] || 0, 2);
            if (team1Dots && team1Dots.length) {
                team1Dots.forEach((dot, idx) => {
                    if (idx < r1) dot.classList.add('filled'); else dot.classList.remove('filled');
                });
            }
            if (team2Dots && team2Dots.length) {
                team2Dots.forEach((dot, idx) => {
                    if (idx < r2) dot.classList.add('filled'); else dot.classList.remove('filled');
                });
            }
            // Hide the deck for teams that have achieved biribaki (>=2)
            if (team1Deck) team1Deck.style.display = (r1 >= 2) ? 'none' : 'flex';
            if (team2Deck) team2Deck.style.display = (r2 >= 2) ? 'none' : 'flex';
            
            console.log('Team scores updated:', teamScores);
        }

        // Update score display in the discrete scoring box (legacy compatibility)
        function updateScoreDisplay() {
            // Now calls the team score update function
            updateTeamScoreDisplay();
        }

        // Create a full deck of 108 cards (2 decks + 4 jokers)
        function createFullDeck() {
            let deck = [];
            
            // Add two standard decks
            for (let deckNum = 0; deckNum < 2; deckNum++) {
                for (let suit of suits) {
                    for (let rank of ranks) {
                        const imageName = getImageName(rank, suit, deckNum);
                        deck.push({
                            suit: suit,
                            rank: rank,
                            id: `${suit}_${rank}_deck${deckNum}_${Date.now()}_${Math.random()}`,
                            imagePath: `cards/${imageName}`
                        });
                    }
                }
            }
            
            // Add 4 jokers
            for (let i = 1; i <= 4; i++) {
                deck.push({
                    suit: 'joker',
                    rank: 'JOKER',
                    id: `joker_${i}_${Date.now()}_${Math.random()}`,
                    imagePath: i <= 2 ? 'cards/red_joker.png' : 'cards/black_joker.png'
                });
            }
            
            return shuffleArray(deck);
        }

        // Get correct image name for card
        function getImageName(rank, suit, deckNum) {
            let rankName;
            if (rank === 'A') rankName = 'ace';
            else if (rank === 'J') rankName = 'jack';
            else if (rank === 'Q') rankName = 'queen';
            else if (rank === 'K') rankName = 'king';
            else rankName = rank;
            
            // For second deck, face cards have "2" suffix
            const suffix = (deckNum === 1 && ['J', 'Q', 'K'].includes(rank)) ? '2' : '';
            return `${rankName}_of_${suit}${suffix}.png`;
        }

        // Shuffle array function
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Get suit symbol
        function getSuitSymbol(suit) {
            const symbols = {
                hearts: '',
                diamonds: '',
                clubs: '',
                spades: ''
            };
            return symbols[suit] || '';
        }

        // Update the atou indicator UI
        function updateAtouIndicator() {
            const el = document.getElementById('atou-indicator');
            const label = document.getElementById('atou-label');
            if (!el) return;
            const suit = gameState.atouSuit;
            if (!suit || suit === 'joker') {
                el.textContent = '?';
                el.classList.add('hidden');
                if (label) label.classList.add('hidden');
                return;
            }
            el.textContent = getSuitSymbol(suit);
            el.classList.remove('hidden');
            if (label) label.classList.remove('hidden');
            // Optional color tweak per suit
            let color = '#FFD700';
            if (suit === 'hearts' || suit === 'diamonds') color = '#ff4d4d';
            el.style.color = color;
        }

        // If atou is pending (first card was joker), allow the current player to choose the atou suit
        function promptAtouSelectionIfNeeded() {
            if (!gameState.atouPending) return;
            // Only the player whose turn it is may choose
            if (loginState.myPlayerId !== gameState.currentTurn) return;

            // Build a nice popup with 4 circle buttons
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            const popup = document.createElement('div');
            popup.className = 'popup';
            popup.style.maxWidth = '360px';
            popup.style.textAlign = 'center';
            const title = document.createElement('h3');
            title.textContent = 'Select ATOU Suit';
            popup.appendChild(title);

            const row = document.createElement('div');
            row.className = 'atou-select-row';

            const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
            suits.forEach(suit => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'atou-select-btn';
                btn.textContent = getSuitSymbol(suit);
                if (suit === 'hearts' || suit === 'diamonds') {
                    btn.style.color = '#ff4d4d';
                }
                btn.addEventListener('click', () => {
                    // Apply choice
                    gameState.atouSuit = suit;
                    gameState.atouPending = false;
                    updateAtouIndicator();
                    socket.emit('action', { type: 'setAtouSuit', suit });
                    document.body.removeChild(overlay);
                });
                row.appendChild(btn);
            });

            popup.appendChild(row);

            const cancelInfo = document.createElement('div');
            cancelInfo.style.marginTop = '10px';
            cancelInfo.style.fontSize = '12px';
            cancelInfo.style.color = 'rgba(255,255,255,0.7)';
            cancelInfo.textContent = 'Only the current player can choose.';
            popup.appendChild(cancelInfo);

            overlay.appendChild(popup);
            document.body.appendChild(overlay);
        }

        // Initialize card picker sidebar
        function initializeCardPicker() {
            // Populate each suit
            suits.forEach(suit => {
                const grid = document.getElementById(`${suit}-grid`);
                ranks.forEach(rank => {
                    const pickerCard = createPickerCard(rank, suit);
                    grid.appendChild(pickerCard);
                });
            });
            
            // Populate jokers
            const jokersGrid = document.getElementById('jokers-grid');
            for (let i = 1; i <= 4; i++) {
                const pickerCard = createPickerCard('JOKER', 'joker', i);
                jokersGrid.appendChild(pickerCard);
            }
        }

        // Create a picker card element
        function createPickerCard(rank, suit, jokerNum = null) {
            const pickerCard = document.createElement('div');
            pickerCard.className = `picker-card ${suit}`;
            
            if (suit === 'joker') {
                pickerCard.textContent = 'JOKER';
            } else {
                const suitSymbol = getSuitSymbol(suit);
                pickerCard.textContent = rank + suitSymbol;
            }
            
            // Add click handler to add card to hand
            pickerCard.addEventListener('click', () => {
                addCardToHand(rank, suit, jokerNum);
            });
            
            return pickerCard;
        }

        // Switch player view perspective
        function switchPlayerView(playerNumber) {
            // Update current player view
            gameState.currentPlayerView = playerNumber;
            
            // Update the active button visual state
            document.querySelectorAll('.player-view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-player="${playerNumber}"]`).classList.add('active');
            
            // Update the player hand reference to show the selected player's hand
            gameState.playerHand = gameState.playerHands[playerNumber - 1];
            
            // Update player name labels based on perspective
            updatePlayerNameLabels();
            
            // Update turn display to show correct player glow for new perspective
            updateTurnDisplay();
            
            // Update player view buttons and meld area labels
            updatePlayerViewButtons();
            updateMeldAreaLabels();
            refreshChatMessages();
            
            // Re-render the hand to show the new player's cards
            renderHand();
            
            console.log(`Switched to Player ${playerNumber} view`);
        }
        
        // Helper function to get card count for any player
        function getPlayerCardCount(playerNumber) {
            return gameState.playerHands[playerNumber - 1].length;
        }

        // Update player name labels based on current perspective
        function updatePlayerNameLabels() {
            const currentPlayer = gameState.currentPlayerView;
            
            // Define the player positions for each perspective
            const perspectives = {
                1: { bottom: 1, right: 2, top: 3, left: 4 },
                2: { bottom: 2, right: 3, top: 4, left: 1 },
                3: { bottom: 3, right: 4, top: 1, left: 2 },
                4: { bottom: 4, right: 1, top: 2, left: 3 }
            };
            
            const layout = perspectives[currentPlayer];
            
            // Update each label with card count
            const bottomCount = getPlayerCardCount(layout.bottom);
            const rightCount = getPlayerCardCount(layout.right);
            const topCount = getPlayerCardCount(layout.top);
            const leftCount = getPlayerCardCount(layout.left);
            
            document.getElementById('player-name-bottom').querySelector('.player-name-text').textContent = `${playerNames[layout.bottom]} - ${bottomCount} card${bottomCount === 1 ? '' : 's'}`;
            document.getElementById('player-name-right').querySelector('.player-name-text').textContent = `${playerNames[layout.right]} - ${rightCount} card${rightCount === 1 ? '' : 's'}`;
            document.getElementById('player-name-top').querySelector('.player-name-text').textContent = `${playerNames[layout.top]} - ${topCount} card${topCount === 1 ? '' : 's'}`;
            document.getElementById('player-name-left').querySelector('.player-name-text').textContent = `${playerNames[layout.left]} - ${leftCount} card${leftCount === 1 ? '' : 's'}`;
        }

        // Add a card to the current player's hand
        function addCardToHand(rank, suit, jokerNum = null) {
            const cardId = jokerNum ? `joker_${jokerNum}_${Date.now()}` : `${suit}_${rank}_${Date.now()}`;
            
            // Create card with proper image path
            let imagePath;
            if (suit === 'joker') {
                imagePath = jokerNum <= 2 ? 'cards/red_joker.png' : 'cards/black_joker.png';
            } else {
                // Use first deck images for picker cards
                const imageName = getImageName(rank, suit, 0);
                imagePath = `cards/${imageName}`;
            }
            
            const newCard = {
                suit: suit,
                rank: rank,
                id: cardId,
                imagePath: imagePath
            };
            
            // Add to the current player's hand (playerHand is a reference to playerHands[currentPlayerView - 1])
            gameState.playerHand.push(newCard);
            
            // Update hand and check for biribaki distribution using centralized function
            updatePlayerHand(gameState.currentPlayerView);
        }

        // Track previous hand state to detect new cards
        let previousHandCardIds = new Set();

        // Animation helper functions
        function animateCard(cardElement, animationType, delay = 0) {
            setTimeout(() => {
                // Remove any existing animation classes
                cardElement.className = cardElement.className.replace(/card-(dealing|discarding|melding|drawing|hovering|flash|entering)/g, '');
                
                // Add the new animation class
                cardElement.classList.add(`card-${animationType}`);
                
                // Remove the animation class after it completes
                const animationDuration = {
                    'dealing': 600,
                    'discarding': 1200,
                    'melding': 500,
                    'drawing': 500,
                    'hovering': 200,
                    'flash': 600,
                    'entering': 300
                };
                
                setTimeout(() => {
                    cardElement.classList.remove(`card-${animationType}`);
                }, animationDuration[animationType] || 500);
            }, delay);
        }

        function animateNewCard(cardElement, index = 0) {
            // Stagger dealing animations for multiple cards
            animateCard(cardElement, 'dealing', index * 100);
        }

        function animateCardEnter(cardElement, index = 0) {
            // Animate card entering from the right with minimal delay
            animateCard(cardElement, 'entering', index * 10);
        }

        function animateDiscard(cardElement, callback) {
            animateCard(cardElement, 'discarding');
            // Call callback after discard animation completes
            setTimeout(() => {
                if (callback) callback();
            }, 1200);
        }

        function animateMeld(cardElements) {
            cardElements.forEach((cardElement, index) => {
                animateCard(cardElement, 'melding', index * 50);
            });
        }

        function animateDraw(cardElement) {
            animateCard(cardElement, 'drawing');
        }

        function flashCard(cardElement) {
            animateCard(cardElement, 'flash');
        }

        // Create hand card element with image
        function createHandCard(card) {
            const cardElement = document.createElement('div');
            cardElement.className = `hand-card ${card.suit}`;
            cardElement.dataset.cardId = card.id;
            
            // Use background image instead of text
            if (card.imagePath) {
                cardElement.style.backgroundImage = `url("${card.imagePath}")`;
                cardElement.style.backgroundSize = 'contain';
                cardElement.style.backgroundPosition = 'center';
                cardElement.style.backgroundRepeat = 'no-repeat';
                cardElement.textContent = ''; // Remove text when using image
            } else {
                // Fallback to text if no image
                if (card.suit === 'joker') {
                    cardElement.textContent = 'JOKER';
                } else {
                    const suitSymbol = getSuitSymbol(card.suit);
                    cardElement.textContent = card.rank + suitSymbol;
                }
            }
            
            // Add click handler for selection
            cardElement.addEventListener('click', () => {
                toggleCardSelection(card.id, cardElement);
            });
            
            // Add drag functionality for reordering
            cardElement.draggable = true;
            cardElement.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', card.id);
                e.dataTransfer.effectAllowed = 'move';
                draggedCardId = card.id;
                cardElement.style.opacity = '0.5';
                cardElement.classList.add('dragging');
                
                // Play drag sound when dragging from hand
                playDragSound();                console.log('Started dragging card:', card.id);
            });
            
            cardElement.addEventListener('dragend', (e) => {
                cardElement.style.opacity = '1';
                cardElement.classList.remove('dragging');
                draggedCardId = null;
                // Remove all drop indicators
                document.querySelectorAll('.drop-indicator').forEach(indicator => {
                    indicator.remove();
                });
                console.log('Finished dragging card:', card.id);
            });
            
            // Add drop functionality for reordering
            cardElement.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                // Only allow reordering within the same hand
                if (draggedCardId && draggedCardId !== card.id) {
                    const rect = cardElement.getBoundingClientRect();
                    const midX = rect.left + rect.width / 2;
                    
                    // Remove existing indicators
                    document.querySelectorAll('.drop-indicator').forEach(indicator => {
                        indicator.remove();
                    });
                    
                    // Create drop indicator
                    const indicator = document.createElement('div');
                    indicator.className = 'drop-indicator';
                    indicator.style.position = 'absolute';
                    indicator.style.left = e.clientX < midX ? '-2px' : 'calc(100% - 2px)';
                    indicator.style.top = '0px';
                    indicator.style.width = '4px';
                    indicator.style.height = '100%';
                    indicator.style.backgroundColor = '#FFD700';
                    indicator.style.borderRadius = '2px';
                    indicator.style.zIndex = '1000';
                    indicator.style.pointerEvents = 'none';
                    indicator.style.boxShadow = '0 0 8px rgba(255, 215, 0, 0.8)';
                    
                    // Ensure the card has relative positioning
                    if (cardElement.style.position !== 'relative') {
                        cardElement.style.position = 'relative';
                    }
                    cardElement.appendChild(indicator);
                    
                    console.log('Showing drop indicator for card:', card.id, 'at position:', e.clientX < midX ? 'left' : 'right');
                }
            });
            
            cardElement.addEventListener('drop', (e) => {
                e.preventDefault();
                
                if (draggedCardId && draggedCardId !== card.id) {
                    // Find the dragged card and target card indices
                    const draggedIndex = gameState.playerHand.findIndex(c => c.id === draggedCardId);
                    const targetIndex = gameState.playerHand.findIndex(c => c.id === card.id);
                    
                    if (draggedIndex !== -1 && targetIndex !== -1) {
                        // Determine drop position (left or right of target)
                        const rect = cardElement.getBoundingClientRect();
                        const midX = rect.left + rect.width / 2;
                        const insertIndex = e.clientX < midX ? targetIndex : targetIndex + 1;
                        
                        // Remove dragged card from its current position
                        const draggedCard = gameState.playerHand.splice(draggedIndex, 1)[0];
                        
                        // Insert at new position (adjust index if we removed before the target)
                        const adjustedIndex = draggedIndex < insertIndex ? insertIndex - 1 : insertIndex;
                        gameState.playerHand.splice(adjustedIndex, 0, draggedCard);
                        
                        // Update the playerHands array as well
                        gameState.playerHands[gameState.currentPlayerView - 1] = [...gameState.playerHand];
                        
                        // Re-render the hand
                        renderHand();
                        
                        console.log(`Moved card ${draggedCardId} to position ${adjustedIndex}`);
                    }
                }
                
                // Remove drop indicators
                document.querySelectorAll('.drop-indicator').forEach(indicator => {
                    indicator.remove();
                });
            });
            
            cardElement.addEventListener('dragleave', (e) => {
                // Only remove indicators if we're actually leaving the card (not just moving within it)
                if (!cardElement.contains(e.relatedTarget)) {
                    document.querySelectorAll('.drop-indicator').forEach(indicator => {
                        indicator.remove();
                    });
                }
            });
            
            
            return cardElement;
        }

        // Toggle card selection
        function toggleCardSelection(cardId, cardElement) {
            const index = gameState.selectedCards.indexOf(cardId);
            
            if (index === -1) {
                // Select card
                gameState.selectedCards.push(cardId);
                cardElement.classList.add('selected');
            } else {
                // Deselect card
                gameState.selectedCards.splice(index, 1);
                cardElement.classList.remove('selected');
            }
        }

        // Render player hand
        function renderHand() {
            console.log(`=== RENDER HAND DEBUG ===`);
            console.log(`renderHand called - Current player view: ${gameState.currentPlayerView}`);
            console.log(`gameState.playerHand length: ${gameState.playerHand.length}`);
            console.log(`gameState.playerHands[${gameState.currentPlayerView - 1}] length: ${gameState.playerHands[gameState.currentPlayerView - 1].length}`);
            console.log(`=== END RENDER HAND DEBUG ===`);
            
            const handArea = document.getElementById('player-hand');
            const currentCardIds = new Set(gameState.playerHand.map(card => card.id));
            
            // Find new cards (cards that weren't in the previous hand)
            const newCardIds = new Set([...currentCardIds].filter(id => !previousHandCardIds.has(id)));
            
            // Find removed cards (cards that were in the previous hand but aren't now)
            const removedCardIds = new Set([...previousHandCardIds].filter(id => !currentCardIds.has(id)));
            
            // Remove cards that are no longer in the hand
            removedCardIds.forEach(cardId => {
                const existingCard = document.querySelector(`[data-card-id="${cardId}"]`);
                if (existingCard) {
                    existingCard.remove();
                }
            });
            
            // Add new cards or update existing ones, and reorder them
            gameState.playerHand.forEach((card, index) => {
                let cardElement = document.querySelector(`[data-card-id="${card.id}"]`);
                
                if (!cardElement) {
                    // Create new card element
                    cardElement = createHandCard(card);
                    
                    // If it's a new card, start it off-screen and add animation class immediately
                    if (newCardIds.has(card.id)) {
                        cardElement.style.transform = 'translateX(100px) scale(0.8)';
                        cardElement.style.opacity = '0';
                        handArea.appendChild(cardElement);
                        
                        // Force a reflow, then start animation
                        cardElement.offsetHeight;
                        animateCardEnter(cardElement, index);
                        
                        // Clean up inline styles after animation completes
                        setTimeout(() => {
                            cardElement.style.transform = '';
                            cardElement.style.opacity = '';
                        }, 300);
                    } else {
                        handArea.appendChild(cardElement);
                    }
                } else {
                    // Update existing card's selection state
                if (gameState.selectedCards.includes(card.id)) {
                    cardElement.classList.add('selected');
                    } else {
                        cardElement.classList.remove('selected');
                    }
                    
                    // Reorder the card to match the new position in the sorted array
                    const currentPosition = Array.from(handArea.children).indexOf(cardElement);
                    if (currentPosition !== index) {
                        // Move the card to the correct position
                        if (index === 0) {
                            handArea.insertBefore(cardElement, handArea.firstChild);
                        } else {
                            const nextCard = handArea.children[index];
                            if (nextCard) {
                                handArea.insertBefore(cardElement, nextCard);
                            } else {
                handArea.appendChild(cardElement);
                            }
                        }
                    }
                }
            });
            
            // Update the previous hand state for next render
            previousHandCardIds = new Set(currentCardIds);
        }

        // Clear all cards from hand
        function clearHand() {
            gameState.playerHand = [];
            gameState.playerHands[gameState.currentPlayerView - 1] = []; // Fix: Also clear the playerHands array
            gameState.selectedCards = [];
            renderHand();
        }

        // Add a 7-card run to current player's hand and remove the rest (no biribaki trigger)
        function addSevenCardRunToHand() {
            // Choose a suit based on current player view to vary visually
            const suitsOrder = ['spades', 'hearts', 'clubs', 'diamonds'];
            const suit = suitsOrder[(gameState.currentPlayerView - 1) % suitsOrder.length];
            const runRanks = ['7', '8', '9', '10', 'J', 'Q', 'K'];
            const newRun = runRanks.map((rank, idx) => {
                const imageName = getImageName(rank, suit, 0);
                return {
                    suit: suit,
                    rank: rank,
                    id: `devrun_${suit}_${rank}_${Date.now()}_${idx}`,
                    imagePath: `cards/${imageName}`
                };
            });
            // Use updatePlayerHand to properly maintain state and trigger checks
            updatePlayerHand(gameState.currentPlayerView, newRun);
            // Set turn state to allow discarding (same as after drawing a card)
            gameState.hasDrawn = true;
            gameState.turnPhase = 'melding';
            gameState.selectedCards = [];
            
            // Emit action to server to sync state across all clients
            socket.emit('action', { 
                type: 'devSevenCardRun', 
                playerId: loginState.myPlayerId,
                newHand: newRun.map(card => ({
                    suit: card.suit,
                    rank: card.rank,
                    id: card.id
                }))
            });
        }

        // Biribaki Card Checker: preview team's biribaki cards in hand (do not consume pile)
        // Replaces hand with a copy of team biribaki; keeps pile intact; avoids biribaki trigger
        function biribakiCardChecker(playerNum = gameState.currentPlayerView) {
            console.log(`=== BIRIBAKI CHECKER DEBUG ===`);
            console.log(`biribakiCardChecker called for Player ${playerNum}`);
            console.log(`Current player view: ${gameState.currentPlayerView}`);
            console.log(`My player ID: ${loginState.myPlayerId}`);
            
            const team = getPlayerTeam(playerNum);
            const pile = gameState.teamBiribakia && gameState.teamBiribakia[team] ? gameState.teamBiribakia[team] : [];
            console.log(`Team ${team} biribaki pile size: ${pile.length}`);
            
            // Clone cards; ensure IDs are unique in hand to avoid collisions
            // Sort deterministically by rank then suit to ensure consistent preview across teammates
            const sorted = sortByRank(pile);
            const cloned = sorted.map((card, idx) => ({
                suit: card.suit,
                rank: card.rank,
                id: `biribaki_preview_${team}_${idx}`,
                imagePath: card.imagePath
            }));
            
            console.log(`Before setting hand - Player ${playerNum} hand size: ${gameState.playerHands[playerNum - 1].length}`);
            console.log(`Before setting hand - Current view hand size: ${gameState.playerHands[gameState.currentPlayerView - 1].length}`);
            
            const p = playerNum - 1;
            gameState.playerHands[p] = [...cloned];
            
            // Only update current player hand if this is the current view
            if (playerNum === gameState.currentPlayerView) {
                gameState.playerHand = gameState.playerHands[p];
            }

            playBiribakiSound();
            
            gameState.selectedCards = [];
            
            // Set turn state to allow discarding (same as after drawing a card)
            gameState.hasDrawn = true;
            gameState.turnPhase = 'melding';
            
            console.log(`After setting hand - Player ${playerNum} hand size: ${gameState.playerHands[playerNum - 1].length}`);
            console.log(`After setting hand - Current view hand size: ${gameState.playerHands[gameState.currentPlayerView - 1].length}`);
            console.log(`=== END BIRIBAKI CHECKER DEBUG ===`);
            
            updatePlayerNameLabels();
            renderHand();
        }

        // Skip turn function for dev tools
        function skipTurn() {
            // Check if it's the current player's turn
            if (gameState.currentTurn !== loginState.myPlayerId) {
                showPopup('Not Your Turn', `It's Player ${gameState.currentTurn}'s turn. You cannot skip turns.`, true);
                return;
            }
            
            console.log(`Player ${loginState.myPlayerId} is skipping their turn`);
            
            // Advance to next player's turn
            const oldTurn = gameState.currentTurn;
            advanceToNextTurn();
            console.log(`Turn advanced from Player ${oldTurn} to Player ${gameState.currentTurn}`);
            
            // Reset turn state
            gameState.hasDrawn = false;
            gameState.canPickUp = true;
            gameState.turnPhase = 'waiting';
            
            // Update displays
            updatePlayerNameLabels();
            updateTurnDisplay();
            updateGameStatus();
            updateMeldButtonsState();
            updateDiscardAvailability();
            
            // Send action to server for other players
            socket.emit('action', { 
                type: 'skipTurn', 
                playerId: loginState.myPlayerId
            });
            
            console.log(`Skip turn action sent to server: Player ${loginState.myPlayerId}`);
        }

        // Check if a player slot is empty (no player has joined that slot)
        function isPlayerSlotEmpty(playerNumber) {
            return !joinedPlayers.has(playerNumber) || !gameState.turnOrder.includes(playerNumber);
        }

        // Automatically skip turn for empty player slots (one-time check)
        function checkAndSkipEmptyPlayerTurn() {
            if (isPlayerSlotEmpty(gameState.currentTurn)) {
                console.log(`Player ${gameState.currentTurn} slot is empty - automatically skipping turn`);
                
                // Advance to next player's turn
                const oldTurn = gameState.currentTurn;
                advanceToNextTurn();
                console.log(`Turn automatically advanced from Player ${oldTurn} to Player ${gameState.currentTurn}`);
                
                // Reset turn state
                gameState.hasDrawn = false;
                gameState.canPickUp = true;
                gameState.turnPhase = 'waiting';
                
                // Update displays
                updatePlayerNameLabels();
                updateGameStatus();
                updateMeldButtonsState();
                updateDiscardAvailability();
                
                // Send action to server for other players
                socket.emit('action', { 
                    type: 'skipTurn', 
                    playerId: oldTurn
                });
                
                console.log(`Auto-skip turn action sent to server: Player ${oldTurn}`);
            }
        }

        // Draw card from stock (Phase 5: Basic Actions)
        function drawCard() {
            // Check if it's the current player's turn using the actual logged-in player ID
            if (loginState.isSpectator) {
                showPopup('Spectator', 'Spectators cannot perform actions.', true);
                return;
            }
            if (gameState.currentTurn !== loginState.myPlayerId) {
                showPopup('Not Your Turn', `It's Player ${gameState.currentTurn}'s turn. You cannot draw cards.`, true);
                return;
            }
            
            if (!gameState.canPickUp) {
                alert('You must discard a card before drawing again!');
                return;
            }
            
            if (gameState.deck.length > 0) {
                // Play card pickup sound
                playCardSound();
                
                // Execute action locally first using the actual logged-in player ID
                applyDrawStockAction(loginState.myPlayerId);
                
                // Send action to server for other players
                socket.emit('action', { type: 'drawStock' });
                
                console.log('Draw stock action sent to server');
            }
        }

        // Pick up all cards from discard pile (Phase 5: Basic Actions)
        function pickUpDiscardPile() {
            // Check if it's the current player's turn using the actual logged-in player ID
            if (loginState.isSpectator) {
                showPopup('Spectator', 'Spectators cannot perform actions.', true);
                return;
            }
            if (gameState.currentTurn !== loginState.myPlayerId) {
                showPopup('Not Your Turn', `It's Player ${gameState.currentTurn}'s turn. You cannot pick up cards.`, true);
                return;
            }
            
            if (!gameState.canPickUp) {
                alert('You must discard a card before drawing again!');
                return;
            }
            
            if (gameState.discardPile.length > 0) {
                // Play card pickup sound
                playCardSound();
                
                // Execute action locally first using the actual logged-in player ID
                applyPickDiscardAction(loginState.myPlayerId);
                
                // Send action to server for other players
                socket.emit('action', { type: 'pickDiscard' });
                
                console.log('Pick discard action sent to server');
            }
        }

        // New game - create and shuffle full deck
        function newGame() {
            clearHand();
            
            // Reset animation tracking
            previousHandCardIds = new Set();
            
            // Reset game state
            gameState.playerMelds = [];
            gameState.totalScore = 0;
            gameState.turnPhase = 'waiting';
            gameState.currentTurn = 1; // Reset turn to Player 1
            
            // Reset all player hands
            gameState.playerHands = [[], [], [], []];
            
            // Reset team biribakia
            gameState.teamBiribakia = { 1: [], 2: [] };
            
            // Reset biribaki received counters
            gameState.teamBiribakiReceived = { 1: 0, 2: 0 };
            
            // Update turn order to only include joined players
            gameState.turnOrder = Array.from(joinedPlayers).sort();
            console.log(`Turn order updated to: ${gameState.turnOrder.join(', ')}`);
            
            // Set current turn to first joined player
            if (gameState.turnOrder.length > 0) {
                gameState.currentTurn = gameState.turnOrder[0];
                console.log(`Current turn set to: Player ${gameState.currentTurn}`);
            } else {
                console.log('No players have joined - cannot set current turn');
            }
            
            // Create and shuffle a new deck of 108 cards
            gameState.deck = createFullDeck();
            
            // Set aside biribakia BEFORE dealing to players
            console.log('Setting aside biribakia for each team...');
            
            // Team 1 biribaki (11 cards)
            for (let i = 0; i < 11; i++) {
                if (gameState.deck.length > 0) {
                    const card = gameState.deck.pop();
                    gameState.teamBiribakia[1].push(card);
                }
            }
            
            // Team 2 biribaki (11 cards)
            for (let i = 0; i < 11; i++) {
                if (gameState.deck.length > 0) {
                    const card = gameState.deck.pop();
                    gameState.teamBiribakia[2].push(card);
                }
            }
            
            console.log(`Team 1 biribaki: ${gameState.teamBiribakia[1].length} cards`);
            console.log(`Team 2 biribaki: ${gameState.teamBiribakia[2].length} cards`);
            
            // Deal 11 cards only to players who have joined
            console.log('Dealing cards to joined players only...');
            const joinedPlayerIndices = [];
            for (let i = 1; i <= 4; i++) {
                if (joinedPlayers.has(i)) {
                    joinedPlayerIndices.push(i - 1); // Convert to 0-based index
                    console.log(`Player ${i} has joined - will receive cards`);
                } else {
                    console.log(`Player ${i} has not joined - will not receive cards`);
                }
            }
            
            if (joinedPlayerIndices.length === 0) {
                console.log('No players have joined - no cards will be dealt');
            } else {
            for (let cardNum = 0; cardNum < 11; cardNum++) {
                    for (const playerIndex of joinedPlayerIndices) {
                    if (gameState.deck.length > 0) {
                        const card = gameState.deck.pop();
                        gameState.playerHands[playerIndex].push(card);
                        }
                    }
                }
            }
            
            // Update backward compatibility reference for Player 1
            gameState.playerHand = gameState.playerHands[0];
            
            // Log card distribution for verification
            console.log('Card distribution:');
            for (let i = 0; i < 4; i++) {
                const playerNumber = i + 1;
                const hasJoined = joinedPlayers.has(playerNumber);
                console.log(`Player ${playerNumber}: ${gameState.playerHands[i].length} cards (${hasJoined ? 'joined' : 'not joined'})`);
            }
            console.log(`Total cards dealt: ${gameState.playerHands.reduce((sum, hand) => sum + hand.length, 0)}`);
            console.log(`Joined players: ${Array.from(joinedPlayers).join(', ')}`);
            
            // Flip first card to discard pile and set Atou suit
            if (gameState.deck.length > 0) {
                const firstCard = gameState.deck.pop();
                gameState.discardPile = [firstCard];
                // Set Atou (trump suit) from the first flipped card
                if (firstCard.suit === 'joker') {
                    gameState.atouSuit = null;
                    gameState.atouPending = true;
                    promptAtouSelectionIfNeeded();
                } else {
                    gameState.atouSuit = firstCard.suit;
                    gameState.atouPending = false;
                    updateAtouIndicator();
                }
                updateDiscardDisplay();
            }
            
            gameState.stockCount = gameState.deck.length;
            gameState.hasDrawn = false;
            gameState.canPickUp = true;
            
            console.log(`Remaining cards in deck: ${gameState.stockCount}`);
            
            // Update stock pile display
            document.getElementById('stock-pile').textContent = gameState.stockCount;
            document.getElementById('stock-pile').style.cursor = 'pointer';
            
            // Clear meld areas
            const player1Area = document.querySelector('.meld-area.player1');
            const player2Area = document.querySelector('.meld-area.player2');
            player1Area.innerHTML = '';
            player2Area.innerHTML = '';
            player1Area.style.flexDirection = '';
            player2Area.style.flexDirection = '';
            
            // Initialize turn display
            updateTurnDisplay();
            
            // Render the initial hand (only Player 1's hand is visible)
            renderHand();
            updateGameStatus();
            updateScoreDisplay();
        }

        // Render discard pile history in sidebar
        function renderDiscardHistory() {
            const discardHistoryElement = document.getElementById('discard-history');
            
            if (gameState.discardPile.length === 0) {
                discardHistoryElement.innerHTML = '<div class="discard-empty">No cards discarded yet</div>';
                return;
            }
            
            // Clear existing content
            discardHistoryElement.innerHTML = '';
            
            // Show cards in reverse order (newest first)
            const reversedPile = [...gameState.discardPile].reverse();
            
            reversedPile.forEach((card, index) => {
                const discardCard = document.createElement('div');
                discardCard.className = `discard-card ${card.suit}`;
                discardCard.title = `${card.rank}${getSuitSymbol(card.suit)} (${gameState.discardPile.length - index} cards ago)`;
                
                // Use card image if available
                if (card.imagePath) {
                    discardCard.style.backgroundImage = `url("${card.imagePath}")`;
                } else {
                    // Fallback to text display
                    const cardText = document.createElement('div');
                    cardText.className = 'discard-card-text';
                    if (card.suit === 'joker') {
                        cardText.textContent = 'JKR';
                    } else {
                        cardText.textContent = card.rank + getSuitSymbol(card.suit);
                    }
                    discardCard.appendChild(cardText);
                }
                
                discardHistoryElement.appendChild(discardCard);
            });
        }

        // Update discard pile display
        function updateDiscardDisplay() {
            const discardPileElement = document.getElementById('discard-pile');
            
            if (gameState.discardPile.length > 0) {
                const topCard = gameState.discardPile[gameState.discardPile.length - 1];
                discardPileElement.className = `card ${topCard.suit}`;
                
                // Use card image if available
                if (topCard.imagePath) {
                    discardPileElement.style.backgroundImage = `url("${topCard.imagePath}")`;
                    discardPileElement.style.backgroundSize = 'contain';
                    discardPileElement.style.backgroundPosition = 'center';
                    discardPileElement.style.backgroundRepeat = 'no-repeat';
                    discardPileElement.textContent = '';
                } else {
                    // Fallback to text
                    if (topCard.suit === 'joker') {
                        discardPileElement.textContent = 'JOKER';
                    } else {
                        const suitSymbol = getSuitSymbol(topCard.suit);
                        discardPileElement.textContent = topCard.rank + suitSymbol;
                    }
                }
                
                // Make it clickable to pick up all cards
                discardPileElement.style.cursor = 'pointer';
                discardPileElement.onclick = pickUpDiscardPile;
            } else {
                // Empty discard pile
                discardPileElement.className = 'card empty';
                discardPileElement.textContent = 'Empty';
                discardPileElement.style.backgroundImage = '';
                discardPileElement.style.cursor = 'default';
                discardPileElement.onclick = null;
            }
            
            // Update discard history in sidebar
            renderDiscardHistory();
        }

        // Update game status display
        function updateGameStatus() {
            const stockPile = document.getElementById('stock-pile');
            
            if (gameState.canPickUp) {
                stockPile.style.opacity = '1';
                stockPile.style.cursor = 'pointer';
            } else {
                stockPile.style.opacity = '0.5';
                stockPile.style.cursor = 'default';
            }
        }

        // Setup drag and drop for discard pile with turn-based restrictions
        function setupDragAndDrop() {
            const discardPile = document.getElementById('discard-pile');
            
            // Setup discard pile with turn phase validation
            discardPile.addEventListener('dragover', (e) => {
                // Only allow drag over if in melding phase
                if (gameState.turnPhase === 'melding' && gameState.hasDrawn) {
                    e.preventDefault();
                    discardPile.classList.add('drag-over');
                } else {
                    // Prevent drop by not calling preventDefault
                    discardPile.classList.remove('drag-over');
                }
            });
            
            discardPile.addEventListener('dragleave', (e) => {
                discardPile.classList.remove('drag-over');
            });
            
            discardPile.addEventListener('drop', (e) => {
                // Double-check turn phase before allowing drop
                if (gameState.turnPhase === 'melding' && gameState.hasDrawn) {
                    e.preventDefault();
                    discardPile.classList.remove('drag-over');
                    const cardId = e.dataTransfer.getData('text/plain');
                    discardCard(cardId);
                } else {
                    // Reject the drop and show error
                    discardPile.classList.remove('drag-over');
                    showPopup('Cannot Discard', 'You must draw a card before you can discard. Pick up from the stock pile or discard pile first.', true);
                }
            });
        }

        // Update discard availability visual feedback
        function updateDiscardAvailability() {
            const discardPile = document.getElementById('discard-pile');
            const handCards = document.querySelectorAll('.hand-card');
            
            const canDiscard = gameState.turnPhase === 'melding' && gameState.hasDrawn;
            
            if (canDiscard) {
                // Enable discarding - normal appearance
                discardPile.style.opacity = '1';
                discardPile.style.filter = 'none';
                discardPile.style.border = '2px solid rgba(255, 255, 255, 0.3)';
                
                // Enable dragging on hand cards
                handCards.forEach(card => {
                    card.draggable = true;
                    card.style.cursor = 'grab';
                });
            } else {
                // Disable discarding - dimmed appearance
                discardPile.style.opacity = '0.5';
                discardPile.style.filter = 'grayscale(50%)';
                discardPile.style.border = '2px solid rgba(255, 0, 0, 0.5)';
                
                // Disable dragging on hand cards
                handCards.forEach(card => {
                    card.draggable = false;
                    card.style.cursor = 'default';
                });
            }
        }

        // Centralized function to update player hands and check for biribaki distribution
        function updatePlayerHand(playerNumber, newHand = null) {
            console.log(`Updating hand for Player ${playerNumber}`);
            
            // Update the specific player's hand
            if (newHand !== null) {
                gameState.playerHands[playerNumber - 1] = [...newHand];
            }
            
            // Update the current view reference if this is the current player
            if (playerNumber === gameState.currentPlayerView) {
                gameState.playerHand = gameState.playerHands[playerNumber - 1];
            }
            
            // Note: Biribaki distribution is now handled at the end of action functions
            // to ensure proper order of operations (e.g., after meld creation is complete)
            
            // Update player name labels to reflect new card counts
            updatePlayerNameLabels();
            
            // Force re-render if this is the current player view
            if (playerNumber === gameState.currentPlayerView) {
                renderHand();
            }
            
            console.log(`Player ${playerNumber} hand updated. Length: ${gameState.playerHands[playerNumber - 1].length}`);
        }

        // Check if player should receive their team's biribaki or if game should end
        function checkForBiribakiDistribution(playerNumber) {
            const playerHand = gameState.playerHands[playerNumber - 1];
            
            console.log(`Checking biribaki distribution for Player ${playerNumber}. Hand size: ${playerHand.length}`);
            
            // Check if player's hand is empty
            if (playerHand.length === 0) {
                const playerTeam = getPlayerTeam(playerNumber);
                
                // END GAME CHECK: If team has already received their biribaki, check for BIRIBA requirement
                if (gameState.teamBiribakiReceived[playerTeam] > 0) {
                    // Check if the team has a BIRIBA meld (7+ cards) to end the game
                    if (teamHasBiriba(playerTeam)) {
                        console.log(`Player ${playerNumber} (Team ${playerTeam}) went out after biribaki with BIRIBA - GAME ENDS!`);
                        endGame(playerTeam);
                        return true; // Game ended
                    } else {
                        // Team doesn't have a BIRIBA - cannot end the game
                        console.log(`Player ${playerNumber} (Team ${playerTeam}) tried to go out but team has no BIRIBA meld`);
                        // Suppress popup per request; keep state as is
                        return false; // Game continues, player's hand stays empty
                    }
                }
                
                const teamBiribaki = gameState.teamBiribakia[playerTeam];
                
                console.log(`Player ${playerNumber} hand is empty. Team ${playerTeam} biribaki available: ${teamBiribaki.length} cards`);
                
                // Instead of consuming biribaki, auto-preview it using the checker for this player
                if (teamBiribaki.length > 0) {
                    // Increment the biribaki received counter for this team
                    gameState.teamBiribakiReceived[playerTeam]++;
                    console.log(`Team ${playerTeam} has received biribaki ${gameState.teamBiribakiReceived[playerTeam]} time(s)`);
                    
                    // Check if this is the second time the team receives biribaki
                    if (gameState.teamBiribakiReceived[playerTeam] >= 2) {
                        console.log(`Team ${playerTeam} has received biribaki for the second time - GAME ENDS!`);
                        endGame(playerTeam);
                        return true; // Game ended
                    }
                    
                    // Call biribaki checker locally first
                    biribakiCardChecker(playerNumber);
                    
                    // Store the biribaki preview action to be emitted later
                    // This will be handled by the calling function (e.g., applyDiscardAction)
                    return { needsSync: true, playerId: playerNumber, team: playerTeam };
                }
            }
            
            return false; // No biribaki distribution occurred
        }

        // Discard card with strict turn-based validation (Phase 5: Basic Actions)
        function discardCard(cardId) {
            console.log(`=== DISCARD CARD FUNCTION DEBUG ===`);
            console.log(`discardCard called with cardId: ${cardId}`);
            console.log(`Current turn: ${gameState.currentTurn}, My player ID: ${loginState.myPlayerId}`);
            console.log(`Turn phase: ${gameState.turnPhase}, Has drawn: ${gameState.hasDrawn}`);
            if (loginState.isSpectator) {
                showPopup('Spectator', 'Spectators cannot perform actions.', true);
                return;
            }
            
            // Strict validation: Can only discard during melding phase (after drawing)
            if (gameState.turnPhase !== 'melding') {
                console.log('DISCARD BLOCKED: Not in melding phase');
                showPopup('Cannot Discard', 'You must draw a card before you can discard. Pick up from the stock pile or discard pile first.', true);
                return;
            }
            
            // Ensure player has drawn a card this turn
            if (!gameState.hasDrawn) {
                console.log('DISCARD BLOCKED: Has not drawn a card this turn');
                showPopup('Cannot Discard', 'You must draw a card before you can discard.', true);
                return;
            }
            
            // Check if it's the current player's turn using the actual logged-in player ID
            if (gameState.currentTurn !== loginState.myPlayerId) {
                console.log(`DISCARD BLOCKED: Not current player's turn (turn: ${gameState.currentTurn}, my ID: ${loginState.myPlayerId})`);
                showPopup('Not Your Turn', `It's Player ${gameState.currentTurn}'s turn. You cannot discard cards.`, true);
                return;
            }
            
            // Use the actual logged-in player's hand, not the viewed player's hand
            const myPlayerHand = gameState.playerHands[loginState.myPlayerId - 1];
            const cardIndex = myPlayerHand.findIndex(card => card.id === cardId);
            console.log(`Card index in my hand: ${cardIndex}`);
            
            if (cardIndex !== -1) {
                // Play flipcard sound when discarding
                playFlipcardSound();
                console.log('EXECUTING DISCARD ACTION LOCALLY...');
                // Execute action locally first using the actual logged-in player ID
                const biribakiResult = applyDiscardAction(loginState.myPlayerId, cardId);
                
                console.log('SENDING DISCARD ACTION TO SERVER...');
                // Send action to server for other players
                socket.emit('action', { type: 'discard', cardId: cardId });
                
                console.log(`Discard action sent to server: { type: 'discard', cardId: '${cardId}' }`);
                
                // If biribaki preview was applied, sync it across all clients AFTER discard is sent
                if (biribakiResult && biribakiResult.needsSync) {
                    console.log('SENDING BIRIBAKI PREVIEW ACTION TO SERVER...');
                    socket.emit('action', { 
                        type: 'biribakiPreview', 
                        playerId: biribakiResult.playerId,
                        team: biribakiResult.team
                    });
                    console.log(`Biribaki preview action sent to server: Player ${biribakiResult.playerId}, Team ${biribakiResult.team}`);
                }
            } else {
                console.error(`DISCARD FAILED: Card ${cardId} not found in my player hand`);
            }
            console.log(`=== END DISCARD CARD FUNCTION DEBUG ===`);
        }

        // Get rank value for sorting (Ace = 1, Jack = 11, Queen = 12, King = 13)
        function getRankValue(rank) {
            if (rank === 'A') return 1;
            if (rank === 'J') return 11;
            if (rank === 'Q') return 12;
            if (rank === 'K') return 13;
            if (rank === 'JOKER') return 14; // Jokers sort last
            return parseInt(rank);
        }

        // Get suit value for sorting (diamonds, clubs, hearts, spades order)
        function getSuitValue(suit) {
            const suitOrder = { 'diamonds': 1, 'clubs': 2, 'hearts': 3, 'spades': 4, 'joker': 5 };
            return suitOrder[suit] || 0;
        }

        // Sort cards by rank
        function sortByRank(cards) {
            return [...cards].sort((a, b) => {
                const rankDiff = getRankValue(a.rank) - getRankValue(b.rank);
                if (rankDiff !== 0) return rankDiff;
                // If ranks are equal, sort by suit
                return getSuitValue(a.suit) - getSuitValue(b.suit);
            });
        }

        // Sort cards by suit (diamonds, clubs, hearts, spades order)
        function sortBySuit(cards) {
            return [...cards].sort((a, b) => {
                const suitDiff = getSuitValue(a.suit) - getSuitValue(b.suit);
                if (suitDiff !== 0) return suitDiff;
                // If suits are equal, sort by rank
                return getRankValue(a.rank) - getRankValue(b.rank);
            });
        }

        // Toggle sort mode and sort the hand
        function toggleSort() {
            const sortBtn = document.getElementById('sort-btn');
            
            if (!sortBtn) {
                console.error('Sort button not found!');
                return;
            }
            
            if (!gameState.playerHand || gameState.playerHand.length === 0) {
                console.log('No cards in hand to sort');
                return;
            }
            
            if (gameState.sortMode === 'rank') {
                // Switch to suit sorting
                gameState.sortMode = 'suit';
                const sortedHand = sortBySuit(gameState.playerHand);
                // Update using centralized function to maintain references
                updatePlayerHand(gameState.currentPlayerView, sortedHand);
                sortBtn.textContent = 'Sort by Rank';
            } else {
                // Switch to rank sorting
                gameState.sortMode = 'rank';
                const sortedHand = sortByRank(gameState.playerHand);
                // Update using centralized function to maintain references
                updatePlayerHand(gameState.currentPlayerView, sortedHand);
                sortBtn.textContent = 'Sort by Suit';
            }
        }

        // Run creation system
        
        // Check if a card is wild (2 or JOKER)
        // 2s are wild EXCEPT when they sit naturally in a sequence
        function isWild(card, allCards, runSuit) {
            if (card.rank === 'JOKER') return true;
            
            if (card.rank === '2') {
                // If no run suit determined yet, treat as wild for now
                if (!runSuit) return true;
                
                // If 2 is not the same suit as the run, it's wild
                if (card.suit !== runSuit) return true;
                
                // Get all non-joker cards of the same suit
                const sameSuitCards = allCards.filter(c => 
                    c.suit === card.suit && c.rank !== 'JOKER'
                );
                
                // Get the ranks present (excluding this specific 2 to avoid counting it twice)
                const otherCards = sameSuitCards.filter(c => c.id !== card.id);
                const otherRanks = otherCards.map(c => c.rank);
                
                // Check if this 2 can be natural by looking at adjacent cards
                const hasAce = otherRanks.includes('A');
                const has3 = otherRanks.includes('3');
                
                // A 2 is natural if it can form A-2-3 sequence
                if (hasAce && has3) {
                    return false; // 2 is natural in A-2-3
                }
                
                // A 2 is natural if it can form 2-3-4 sequence (consecutive cards only)
                if (has3) {
                    // Check if we have the consecutive card (4) to form 2-3-4
                    const has4 = otherRanks.includes('4');
                    
                    if (has4) {
                        return false; // 2 is natural in 2-3-4 sequence
                    }
                    // If we have 3 but no 4, then 2 cannot be natural in a 2-3-X sequence
                    // The 2 must be wild to fill a gap (e.g., 3-4-5 where 2 represents 4)
                }
                
                // Otherwise, 2 is wild
                return true;
            }
            
            return false;
        }
        
        // Get rank value for LOW orientation (A=1)
        function getRankValueLow(rank) {
            if (rank === 'A') return 1;
            if (rank === 'J') return 11;
            if (rank === 'Q') return 12;
            if (rank === 'K') return 13;
            return parseInt(rank);
        }
        
        // Get rank value for HIGH orientation (A=14)
        function getRankValueHigh(rank) {
            if (rank === 'A') return 14;
            if (rank === 'J') return 11;
            if (rank === 'Q') return 12;
            if (rank === 'K') return 13;
            return parseInt(rank);
        }
        
        // Convert rank value back to rank string
        function rankValueToString(value, orientation) {
            if (orientation === 'LOW' && value === 1) return 'A';
            if (orientation === 'HIGH' && value === 14) return 'A';
            if (value === 11) return 'J';
            if (value === 12) return 'Q';
            if (value === 13) return 'K';
            return value.toString();
        }

        // --- Display ordering helpers for melds ---
        // Compute assigned numeric rank for a run card, honoring wild assignments and orientation
        function getAssignedRunRankForDisplay(card, run) {
            const getRV = run.orientation === 'LOW' ? getRankValueLow : getRankValueHigh;
            // If we have an explicit wildMap from creation, use it
            if (run.wildMap && typeof run.wildMap.get === 'function' && run.wildMap.has(card.id)) {
                return run.wildMap.get(card.id);
            }
            // If card is natural, return its rank value in this orientation
            const natural = !isWild(card, run.cards || [], run.suit);
            if (natural) return getRV(card.rank);
            // Fallback for wilds without map: place after current max
            if (typeof run.maxRank === 'number') return run.maxRank + 1;
            return getRV(card.rank);
        }

        // Order a run's cards for display: highest assigned rank at the bottom of the stack
        function orderRunCardsForDisplay(run) {
            const cards = [...(run.cards || [])];
            return cards.sort((a, b) => {
                const ra = getAssignedRunRankForDisplay(a, run);
                const rb = getAssignedRunRankForDisplay(b, run);
                return rb - ra; // descending so highest ends up last in array iteration
            });
        }

        // Derive the target rank for a set from its cards (fallback when rank is missing)
        function deriveSetTargetRank(cards) {
            const counts = new Map();
            cards.forEach(c => {
                if (!c || c.rank === 'JOKER') return;
                const key = c.rank;
                counts.set(key, (counts.get(key) || 0) + 1);
            });
            let best = null; let bestCount = -1;
            counts.forEach((cnt, r) => { if (cnt > bestCount) { best = r; bestCount = cnt; }});
            // If nothing found (all jokers), default to 'A'
            return best || 'A';
        }

        // Order a set's cards for display: naturals first (target rank), wild last; stable by suit
        function orderSetCardsForDisplay(setLike) {
            const cards = [...(setLike.cards || [])];
            const targetRank = setLike.rank || deriveSetTargetRank(cards);
            return cards.sort((a, b) => {
                const aWild = (a.rank === 'JOKER') || (a.rank === '2' && a.rank !== targetRank);
                const bWild = (b.rank === 'JOKER') || (b.rank === '2' && b.rank !== targetRank);
                if (aWild !== bWild) return aWild ? 1 : -1; // naturals first
                // stable by suit then by any rank value for determinism
                const suitDiff = getSuitValue(a.suit) - getSuitValue(b.suit);
                if (suitDiff !== 0) return suitDiff;
                return getRankValue(a.rank) - getRankValue(b.rank);
            });
        }
        
        // Handle special case of exactly two 2s in a run
        // Following the exact 7-step algorithm provided by user
        function handleTwoTwos(selectedCards, twos) {
            // Step 1: Filter - From the candidate run, temporarily ignore all cards 4
            // Keep only: Ace(s), 3(s), and the two 2s (with suits)
            const filteredCards = selectedCards.filter(card => {
                const rankValue = getRankValue(card.rank);
                return rankValue <= 3 || card.rank === '2'; // Keep Aces (1), 2s, and 3s
            });
            
            // Determine run suit from non-2 cards first
            const non2Cards = selectedCards.filter(card => card.rank !== '2');
            const non2Suits = [...new Set(non2Cards.map(card => card.suit))];
            
            if (non2Suits.length > 1) {
                return { valid: false, error: "Mixed suits in non-2 cards" };
            }
            
            if (non2Suits.length === 0) {
                return { valid: false, error: "Cannot determine run suit with only 2s" };
            }
            
            const runSuit = non2Suits[0];
            
            // Get the cards 4 that were temporarily ignored
            const cardsOver3 = selectedCards.filter(card => {
                const rankValue = getRankValue(card.rank);
                return rankValue >= 4;
            });
            
            // Separate same-suit and different-suit 2s
            const sameSuit2s = twos.filter(two => two.suit === runSuit);
            const differentSuit2s = twos.filter(two => two.suit !== runSuit);
            
            // Different-suit 2s are automatically wild
            const automaticWilds = differentSuit2s;
            
            // Get aces and threes from the filtered cards (same suit as run)
            const aces = filteredCards.filter(card => card.rank === 'A' && card.suit === runSuit);
            const threes = filteredCards.filter(card => card.rank === '3' && card.suit === runSuit);
            
            // Step 2: Natural 2 Definition (only applies to same-suit 2s)
            // A 2 is natural if, in its own suit:
            // - it sits above an Ace (A2), or
            // - it sits below a 3 (23), or  
            // - it sits between Ace and 3 (A23)
            function isNatural2(twoCard) {
                if (twoCard.suit !== runSuit) return false; // Different suit 2s handled separately
                
                const hasAce = aces.length > 0;
                const hasThree = threes.length > 0;
                
                // A 2 is natural if it can sit in A-2, 2-3, or A-2-3 position
                return hasAce || hasThree;
            }
            
            let natural2 = null;
            let wild2s = [...automaticWilds]; // Start with automatic wilds from different suits
            
            // Handle same-suit 2s with the 7-step algorithm
            if (sameSuit2s.length === 2) {
                const first2 = sameSuit2s[0];
                const second2 = sameSuit2s[1];
                
                const first2IsNatural = isNatural2(first2);
                const second2IsNatural = isNatural2(second2);
                
                // Apply 7-step algorithm to same-suit 2s
                if (first2IsNatural) {
                    natural2 = first2;
                    wild2s.push(second2);
                } else if (second2IsNatural) {
                    natural2 = second2;
                    wild2s.push(first2);
                } else {
                    return { valid: false, error: "Cannot create valid run with two same-suit 2s - neither can be natural" };
                }
                
                // Step 6: If both same-suit 2s are natural, keep first as natural
                if (first2IsNatural && second2IsNatural) {
                    natural2 = first2;
                    wild2s = wild2s.filter(w => w.id !== second2.id); // Remove second2 if it was added
                    wild2s.push(second2);
                }
            } else if (sameSuit2s.length === 1) {
                // Only one same-suit 2, check if it can be natural
                const singleSameSuit2 = sameSuit2s[0];
                if (isNatural2(singleSameSuit2)) {
                    natural2 = singleSameSuit2;
                } else {
                    wild2s.push(singleSameSuit2);
                }
            }
            // If sameSuit2s.length === 0, all 2s are different-suit and already in automaticWilds
            
            // Check wild constraint: only one wild allowed per run
            if (wild2s.length > 1) {
                return { valid: false, error: "Too many wild cards - only one wild allowed per run" };
            }
            
            
            // Step 7: Rebuild Run
            // Bring the 4 cards back in
            // Insert the natural 2 in its fixed spot (if any)
            // Place wild 2s wherever needed
            
            // Create the natural base: Aces, natural 2 (if any), 3s
            const naturalBase = [...aces];
            if (natural2) {
                naturalBase.push(natural2);
            }
            naturalBase.push(...threes);
            
            // All cards including wild 2s and higher cards
            const allCards = [...naturalBase, ...wild2s, ...cardsOver3];
            
            // Determine where wild 2s should go (if any)
            const wildMap = new Map();
            
            if (wild2s.length === 1) {
                // Get all natural ranks (including the natural 2 if any)
                const naturalRanks = naturalBase.map(card => getRankValue(card.rank)).sort((a, b) => a - b);
                const higherRanks = cardsOver3.map(card => getRankValue(card.rank)).sort((a, b) => a - b);
                const allRanks = [...naturalRanks, ...higherRanks].sort((a, b) => a - b);
                
                // Find where the wild 2 should be placed
                let wildRank = 3; // Default
                
                // Look for gaps in the sequence
                for (let i = 0; i < allRanks.length - 1; i++) {
                    if (allRanks[i + 1] - allRanks[i] > 1) {
                        // Found a gap, place wild 2 here
                        wildRank = allRanks[i] + 1;
                        break;
                    }
                }
                
                // If no gaps, place at the end or beginning as needed
                if (wildRank === 3 && !naturalRanks.includes(3) && !higherRanks.includes(3)) {
                    // If we don't have a 3, the wild 2 represents 3
                    wildRank = 3;
                } else if (wildRank === 3) {
                    // Find another position
                    const minRank = Math.min(...allRanks);
                    const maxRank = Math.max(...allRanks);
                    
                    // Try to place it to extend the sequence
                    if (minRank > 1) {
                        wildRank = minRank - 1;
                    } else {
                        wildRank = maxRank + 1;
                    }
                }
                
                // Assign the wild rank
                wildMap.set(wild2s[0].id, wildRank);
            }
            
            // Final Validity Check
            // Run must be consecutive ranks, length 3
            const naturalRanks = naturalBase.map(card => getRankValue(card.rank)).sort((a, b) => a - b);
            const higherRanks = cardsOver3.map(card => getRankValue(card.rank)).sort((a, b) => a - b);
            const wildRanks = wild2s.length > 0 ? [wildMap.get(wild2s[0].id)] : [];
            const finalRanks = [...naturalRanks, ...wildRanks, ...higherRanks].sort((a, b) => a - b);
            const minRank = Math.min(...finalRanks);
            const maxRank = Math.max(...finalRanks);
            
            // Check if sequence is consecutive
            const expectedLength = maxRank - minRank + 1;
            if (finalRanks.length !== expectedLength) {
                return { valid: false, error: "Cannot create consecutive sequence with two 2s" };
            }
            
            if (finalRanks.length < 3) {
                return { valid: false, error: "Run too short" };
            }
            
            return {
                valid: true,
                suit: runSuit,
                orientation: 'LOW', // Always use LOW for simplicity
                cards: allCards,
                wildMap: wildMap,
                minRank: minRank,
                maxRank: maxRank,
                length: allCards.length,
                isClean: wild2s.length === 0, // Clean only if no wilds
                isBiriba: allCards.length >= 7
            };
        }
        
        // Helper function to try creating a run with a specific arrangement
        function tryCreateRunWithArrangement(cards, extraWild = null) {
            // Use existing logic but treat this as if we're testing a normal run
            const potentialNaturals = cards.filter(card => card.rank !== 'JOKER');
            const potentialSuits = [...new Set(potentialNaturals.map(card => card.suit))];
            const detectedRunSuit = potentialSuits.length === 1 ? potentialSuits[0] : null;
            
            // Separate wilds and naturals using contextual logic
            const wilds = cards.filter(card => isWild(card, cards, detectedRunSuit));
            const naturals = cards.filter(card => !isWild(card, cards, detectedRunSuit));
            
            // Add extra wild if provided
            if (extraWild) {
                wilds.push(extraWild);
            }
            
            // Check constraints
            if (wilds.length > 1) {
                return { valid: false, error: "Too many wilds in arrangement" };
            }
            
            if (naturals.length === 0) {
                return { valid: false, error: "Need at least one natural card" };
            }
            
            const naturalSuits = [...new Set(naturals.map(card => card.suit))];
            if (naturalSuits.length > 1) {
                return { valid: false, error: "Mixed suits in naturals" };
            }
            
            const runSuit = naturalSuits[0];
            
            // Try both orientations
            const lowResult = tryOrientation(naturals, wilds, runSuit, 'LOW');
            const highResult = tryOrientation(naturals, wilds, runSuit, 'HIGH');
            
            // Choose best orientation
            if (lowResult.valid && highResult.valid) {
                const lowExtend = (lowResult.minRank - 1) + (13 - lowResult.maxRank);
                const highExtend = (highResult.minRank - 1) + (14 - highResult.maxRank);
                
                if (lowExtend > highExtend) {
                    return lowResult;
                } else if (highExtend > lowExtend) {
                    return highResult;
                } else {
                    return highResult; // Prefer HIGH
                }
            } else if (lowResult.valid) {
                return lowResult;
            } else if (highResult.valid) {
                return highResult;
            } else {
                return { valid: false, error: "Cannot form valid run in either orientation" };
            }
        }
        
        // Handle special case of Ace-2-Wild pattern (A 2 + any wild)
        function handleAceTwoWild(selectedCards) {
            if (selectedCards.length !== 3) {
                return null; // Not applicable
            }
            
            // Find aces and 2s
            const aces = selectedCards.filter(card => card && card.rank === 'A');
            const twos = selectedCards.filter(card => card && card.rank === '2');
            
            // Must have exactly one ace and one 2
            if (aces.length !== 1 || twos.length !== 1) {
                return null; // Not applicable
            }
            
            const ace = aces[0];
            const two = twos[0];
            const remainingCard = selectedCards.find(card => card && card.rank !== 'A' && card.rank !== '2');
            
            // Check if we found the remaining card and it has required properties
            if (!remainingCard || !remainingCard.rank || !remainingCard.suit) {
                return null; // Not applicable
            }
            
            // Check if ace and two have required properties
            if (!ace.suit || !two.suit) {
                return null; // Not applicable
            }
            
            // Ace and 2 must be same suit
            if (ace.suit !== two.suit) {
                return null; // Not applicable
            }
            
            const runSuit = ace.suit;
            
            // Remaining card must be wild (joker or different-suit 2)
            const isWildCard = remainingCard.rank === 'JOKER' || 
                              (remainingCard.rank === '2' && remainingCard.suit !== runSuit);
            
            if (!isWildCard) {
                return null; // Not applicable
            }
            
            // Create the A-2-3 run with wild representing 3
            const wildMap = new Map();
            wildMap.set(remainingCard.id, 3); // Wild represents 3
            
            // Sort cards by rank for display
            const sortedCards = [ace, two, remainingCard];
            
            return {
                valid: true,
                suit: runSuit,
                orientation: 'LOW',
                cards: sortedCards,
                wildMap: wildMap,
                minRank: 1, // Ace
                maxRank: 3, // 3 (represented by wild)
                length: 3,
                isClean: false, // Has a wild
                isBiriba: false // Only 3 cards
            };
        }
        
        // Try to create a valid run from selected cards
        function tryCreateRun(selectedCards) {
            if (selectedCards.length < 3) {
                return { valid: false, error: "Need at least 3 cards for a run" };
            }
            
            // Special handling for Ace-2-Wild pattern
            const aceTwoWildResult = handleAceTwoWild(selectedCards);
            if (aceTwoWildResult) {
                return aceTwoWildResult;
            }
            
            // Special handling for exactly two 2s
            const twos = selectedCards.filter(card => card.rank === '2');
            if (twos.length === 2) {
                return handleTwoTwos(selectedCards, twos);
            }
            
            // More than 2 twos is invalid (impossible case but check anyway)
            if (twos.length > 2) {
                return { valid: false, error: "Cannot have more than 2 twos in a run" };
            }
            
            // Determine suit from naturals first (needed for wild detection)
            const potentialNaturals = selectedCards.filter(card => card.rank !== 'JOKER');
            const potentialSuits = [...new Set(potentialNaturals.map(card => card.suit))];
            const detectedRunSuit = potentialSuits.length === 1 ? potentialSuits[0] : null;
            
            // Separate wilds and naturals using contextual logic
            const wilds = selectedCards.filter(card => isWild(card, selectedCards, detectedRunSuit));
            const naturals = selectedCards.filter(card => !isWild(card, selectedCards, detectedRunSuit));
            
            // ONLY ONE WILD PER RUN constraint
            if (wilds.length > 1) {
                return { valid: false, error: "Only one wild allowed per run" };
            }
            
            // Determine suit from naturals
            if (naturals.length === 0) {
                return { valid: false, error: "Need at least one natural card to determine suit" };
            }
            
            const naturalSuits = [...new Set(naturals.map(card => card.suit))];
            if (naturalSuits.length > 1) {
                return { valid: false, error: "All natural cards must be the same suit" };
            }
            
            const runSuit = naturalSuits[0];
            
            // Try both orientations
            const lowResult = tryOrientation(naturals, wilds, runSuit, 'LOW');
            const highResult = tryOrientation(naturals, wilds, runSuit, 'HIGH');
            
            // Choose best orientation
            if (lowResult.valid && highResult.valid) {
                // Tie-break: prefer orientation with more extendability
                const lowExtend = (lowResult.minRank - 1) + (13 - lowResult.maxRank);
                const highExtend = (highResult.minRank - 1) + (14 - highResult.maxRank);
                
                if (lowExtend > highExtend) {
                    return lowResult;
                } else if (highExtend > lowExtend) {
                    return highResult;
                } else {
                    // If tied, prefer HIGH
                    return highResult;
                }
            } else if (lowResult.valid) {
                return lowResult;
            } else if (highResult.valid) {
                return highResult;
            } else {
                return { valid: false, error: "Cannot form valid run in either orientation" };
            }
        }
        
        // Try to create run in specific orientation
        function tryOrientation(naturals, wilds, suit, orientation) {
            const getRankValue = orientation === 'LOW' ? getRankValueLow : getRankValueHigh;
            
            // Get natural ranks and check for duplicates
            const naturalRanks = naturals.map(card => getRankValue(card.rank));
            const uniqueNaturals = [...new Set(naturalRanks)];
            
            if (naturalRanks.length !== uniqueNaturals.length) {
                return { valid: false, error: `Duplicate ranks in ${orientation} orientation` };
            }
            
            // Find window
            const minNatural = Math.min(...naturalRanks);
            const maxNatural = Math.max(...naturalRanks);
            const naturalSpan = maxNatural - minNatural + 1;
            const naturalCount = naturals.length;
            const wildCount = wilds.length;
            
            // Check if we can fill the gaps
            const gapsInSpan = naturalSpan - naturalCount;
            
            if (gapsInSpan > wildCount) {
                return { valid: false, error: `Not enough wilds to fill gaps in ${orientation} orientation` };
            }
            
            // Create the run
            const window = { min: minNatural, max: maxNatural };
            const wildAssignments = new Map();
            
            // Assign wild to fill gap (if any)
            if (wildCount === 1 && gapsInSpan === 1) {
                // Find the missing rank
                const allRanksInWindow = [];
                for (let r = window.min; r <= window.max; r++) {
                    allRanksInWindow.push(r);
                }
                const missingRank = allRanksInWindow.find(r => !naturalRanks.includes(r));
                wildAssignments.set(wilds[0].id, missingRank);
            } else if (wildCount === 1 && gapsInSpan === 0) {
                // Wild can extend the run (we'll place it at the end for now)
                wildAssignments.set(wilds[0].id, window.max + 1);
                window.max = window.max + 1;
            }
            
            // Final validation
            const finalLength = window.max - window.min + 1;
            if (finalLength < 3) {
                return { valid: false, error: `Run too short in ${orientation} orientation` };
            }
            
            // Create sorted card list
            const sortedCards = [...naturals];
            if (wilds.length > 0) {
                sortedCards.push(wilds[0]);
            }
            
            // Sort by assigned rank
            sortedCards.sort((a, b) => {
                const aRank = isWild(a, [...naturals, ...wilds], suit) ? wildAssignments.get(a.id) : getRankValue(a.rank);
                const bRank = isWild(b, [...naturals, ...wilds], suit) ? wildAssignments.get(b.id) : getRankValue(b.rank);
                return aRank - bRank;
            });
            
            return {
                valid: true,
                suit: suit,
                orientation: orientation,
                cards: sortedCards,
                wildMap: wildAssignments,
                minRank: window.min,
                maxRank: window.max,
                length: finalLength,
                isClean: wilds.length === 0,
                isBiriba: finalLength >= 7
            };
        }
        
        // Sets creation system
        
        // Check if a card is wild for Sets (simpler than runs - 2s are wild unless they're the target rank)
        function isWildForSet(card, targetRank) {
            if (card.rank === 'JOKER') return true;
            
            if (card.rank === '2') {
                // 2s are wild unless they ARE the target rank of the set
                return card.rank !== targetRank;
            }
            
            return false;
        }
        
        // Try to create a valid set from selected cards
        function tryCreateSet(selectedCards) {
            if (selectedCards.length < 3) {
                return { valid: false, error: "Need at least 3 cards for a set" };
            }
            
            // Group cards by rank
            const rankGroups = {};
            selectedCards.forEach(card => {
                if (!rankGroups[card.rank]) {
                    rankGroups[card.rank] = [];
                }
                rankGroups[card.rank].push(card);
            });
            
            // Find the largest group of same-rank cards
            let bestRank = null;
            let bestGroup = [];
            let bestWilds = [];
            
            // Try each rank as the target rank for the set
            for (const [rank, cards] of Object.entries(rankGroups)) {
                if (rank === 'JOKER') continue; // Skip jokers as target rank
                
                // Count natural cards of this rank
                const naturals = cards.filter(card => card.rank === rank);
                
                // Count wilds that could represent this rank
                const wilds = selectedCards.filter(card => isWildForSet(card, rank));
                
                const totalCount = naturals.length + wilds.length;
                
                if (totalCount >= 3 && totalCount > bestGroup.length + bestWilds.length) {
                    bestRank = rank;
                    bestGroup = naturals;
                    bestWilds = wilds.slice(0, Math.min(wilds.length, 1)); // Only one wild per set
                }
            }
            
            // Check if we found a valid set
            if (!bestRank || bestGroup.length + bestWilds.length < 3) {
                return { valid: false, error: "Cannot form a set of 3+ cards of the same rank" };
            }
            
            // Check wild constraint: only one wild allowed per set
            if (bestWilds.length > 1) {
                return { valid: false, error: "Only one wild allowed per set" };
            }
            
            // Combine naturals and wilds
            const setCards = [...bestGroup, ...bestWilds];
            
            // Make sure we're only using the minimum needed cards
            if (setCards.length > selectedCards.length) {
                return { valid: false, error: "Invalid set configuration" };
            }
            
            return {
                valid: true,
                rank: bestRank,
                cards: setCards,
                length: setCards.length,
                isClean: bestWilds.length === 0, // Clean if no wilds
                isBiriba: setCards.length >= 7 // 7+ cards is BIRIBA
            };
        }

        // Strict validator for extending an existing set: all cards must match the set's rank or be valid wilds,
        // and the total wild count across the entire set must not exceed 1
        function tryExtendSet(existingSet, newCards) {
            if (!existingSet || !existingSet.rank || !Array.isArray(existingSet.cards)) {
                return { valid: false, error: 'Invalid existing set data' };
            }
            const targetRank = existingSet.rank;
            const combined = [...existingSet.cards, ...newCards];
            if (combined.length < 3) {
                return { valid: false, error: 'Set too small after extension' };
            }

            // Validate every card is either target rank or a valid wild for that rank
            for (const card of combined) {
                if (!card || !card.rank || !card.suit) {
                    return { valid: false, error: 'Invalid card in extension' };
                }
                const isNatural = card.rank === targetRank;
                const isWildCard = isWildForSet(card, targetRank);
                if (!isNatural && !isWildCard) {
                    return { valid: false, error: `Only ${targetRank}s or wilds (2s/jokers) can be added to this set` };
                }
            }

            // Count wilds in the final set
            const wildCount = combined.filter(card => isWildForSet(card, targetRank) && card.rank !== targetRank).length;
            if (wildCount > 1) {
                return { valid: false, error: 'Only one wild allowed per set' };
            }

            // The final set uses all combined cards
            const finalCards = [...combined];
            return {
                valid: true,
                rank: targetRank,
                cards: finalCards,
                length: finalCards.length,
                isClean: wildCount === 0,
                isBiriba: finalCards.length >= 7
            };
        }
        
        // Create set from selected cards
        function createSetFromSelected() {
            if (loginState.isSpectator) {
                showPopup('Spectator', 'Spectators cannot perform actions.', true);
                return;
            }
            // Check if it's the current player's turn using the actual logged-in player ID
            if (gameState.currentTurn !== loginState.myPlayerId) {
                showPopup('Not Your Turn', `It's Player ${gameState.currentTurn}'s turn. You cannot create melds.`, true);
                return;
            }
            
            // Check if meld creation is allowed
            if (gameState.turnPhase !== 'melding') {
                showPopup('Cannot Create Meld', 'You must draw a card before creating melds.', true);
                return;
            }
            
            try {
                console.log('createSetFromSelected called');
                console.log('Selected cards:', gameState.selectedCards);
                console.log('Player hand:', gameState.playerHand);
                
                if (gameState.selectedCards.length === 0) {
                    console.log('No cards selected');
                    showPopup('No Cards Selected', 'Please select cards to create a set', true);
                    return;
                }
                
                // Get selected card objects with better error handling
                const selectedCardObjects = [];
                for (const cardId of gameState.selectedCards) {
                    const card = gameState.playerHand.find(c => c && c.id === cardId);
                    if (card && card.rank && card.suit && card.id) {
                        selectedCardObjects.push(card);
                    } else {
                        console.error('Invalid card found:', card, 'for cardId:', cardId);
                        console.log('Available card IDs in hand:', gameState.playerHand.map(c => c.id));
                        console.log('Selected card IDs:', gameState.selectedCards);
                        showPopup('Error', 'Card selection is out of sync. Please reselect your cards.', true);
                        // Clear selected cards to force reselection
                        gameState.selectedCards = [];
                        renderHand();
                        return;
                    }
                }
                
                console.log('Selected card objects:', selectedCardObjects);
                
                // Validate all cards have required properties
                for (const card of selectedCardObjects) {
                    if (!card || !card.rank || !card.suit || !card.id) {
                        console.error('Card missing required properties:', card);
                        showPopup('Error', 'Card data is incomplete. Please try again.', true);
                        return;
                    }
                }
                
                const setResult = tryCreateSet(selectedCardObjects);
                console.log('Set result:', setResult);
                
                if (!setResult || !setResult.valid) {
                    const errorMsg = setResult ? setResult.error : 'Unknown error occurred';
                    console.log('Invalid set:', errorMsg);
                    showPopup('Invalid Set', `Cannot create set: ${errorMsg}`, true);
                    return;
                }
                
                console.log('Valid set created, proceeding...');
                
                // Validate set result has required properties
                if (!setResult.cards || !Array.isArray(setResult.cards)) {
                    console.error('Invalid set result - missing cards array:', setResult);
                    showPopup('Error', 'Invalid set result. Please try again.', true);
                    return;
                }
                
                // Check biribaki meld restriction
                const biribakiCheck = canCreateMeldAfterBiribaki(setResult.cards.length, setResult.isBiriba);
                if (!biribakiCheck.allowed) {
                    console.log('Biribaki restriction violated:', biribakiCheck.error);
                    showPopup('Cannot Create Set', biribakiCheck.error, true);
                    return;
                }
                
                // Remove cards from hand using centralized function
                setResult.cards.forEach(card => {
                    if (!card || !card.id) {
                        console.error('Invalid card in set result:', card);
                        return;
                    }
                    
                    const index = gameState.playerHand.findIndex(c => c && c.id === card.id);
                    if (index !== -1) {
                        gameState.playerHand.splice(index, 1);
                    }
                    
                    // Remove from selected
                    const selectedIndex = gameState.selectedCards.indexOf(card.id);
                    if (selectedIndex !== -1) {
                        gameState.selectedCards.splice(selectedIndex, 1);
                    }
                });
                
                // Update hand and check for biribaki distribution using centralized function
                updatePlayerHand(gameState.currentPlayerView);
                
                // Add set to player's meld area
                addSetToPlayArea(setResult);
                
                // Update total score
                updateTotalScore();
                
                // Send meld creation to server for other players (Phase 6: Multiplayer Meld Sync)
                const cardStrings = setResult.cards.map(card => cardToString(card)).filter(str => str !== null);
                socket.emit('action', { 
                    type: 'meldCreate', 
                    kind: 'set', 
                    cards: cardStrings 
                });
                console.log('Set creation action sent to server:', { type: 'meldCreate', kind: 'set', cards: cardStrings });
                
                // Check for biribaki distribution after meld creation
                const biribakiResult = checkForBiribakiDistribution(loginState.myPlayerId);
                if (biribakiResult && biribakiResult.needsSync) {
                    console.log('SENDING BIRIBAKI PREVIEW ACTION TO SERVER...');
                    socket.emit('action', { 
                        type: 'biribakiPreview', 
                        playerId: biribakiResult.playerId,
                        team: biribakiResult.team
                    });
                    console.log(`Biribaki preview action sent to server: Player ${biribakiResult.playerId}, Team ${biribakiResult.team}`);
                }
                
                // Show success popup
                displaySetInfo(setResult);
                
                // Re-render hand
                renderHand();
            } catch (error) {
                console.error('Error in createSetFromSelected:', error);
                console.error('Error stack:', error.stack);
                showPopup('Error', `An error occurred: ${error.message}`, true);
            }
        }
        
        // Helper function to get the correct meld area based on current player view
        function getCurrentPlayerMeldArea() {
            // Players 2 and 4 use Player 2 Play Area, Players 1 and 3 use Player 1 Play Area
            if (gameState.currentPlayerView === 2 || gameState.currentPlayerView === 4) {
                return document.querySelector('.meld-area.player2');
            } else {
                return document.querySelector('.meld-area.player1');
            }
        }

        // Helper function to get team number for a player (1-based)
        function getPlayerTeam(playerNumber) {
            // Team 1: Players 1 and 3
            // Team 2: Players 2 and 4
            return (playerNumber === 1 || playerNumber === 3) ? 1 : 2;
        }

        // Helper function to check if a team has a BIRIBA meld (7+ cards)
        function teamHasBiriba(teamNumber) {
            // Check all melds in the game
            for (const meldData of gameState.playerMelds) {
                if (meldData && meldData.data && meldData.ownerPlayer) {
                    const meldOwnerTeam = getPlayerTeam(meldData.ownerPlayer);
                    
                    // If this meld belongs to the specified team and is a BIRIBA
                    if (meldOwnerTeam === teamNumber && meldData.data.isBiriba) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Helper function to check if meld creation is allowed after biribaki
        function canCreateMeldAfterBiribaki(proposedMeldSize, isProposedMeldBiriba) {
            const currentPlayerTeam = getPlayerTeam(gameState.currentPlayerView);
            
            // If team hasn't received biribaki yet, allow any meld creation
            if (gameState.teamBiribakiReceived[currentPlayerTeam] === 0) {
                return { allowed: true };
            }
            
            // Team has received biribaki - check restriction
            const currentHandSize = gameState.playerHand.length;
            const remainingCards = currentHandSize - proposedMeldSize;
            
            // If remaining cards would be 1 or 0, allow if creating a BIRIBA OR team already has a BIRIBA on the table
            if (remainingCards <= 1) {
                if (isProposedMeldBiriba) {
                    // Allow because creating a BIRIBA (7+ cards)
                    return { allowed: true };
                } else if (teamHasBiriba(currentPlayerTeam)) {
                    // Allow because team already has a BIRIBA meld on the table
                    return { allowed: true };
                } else {
                    // Deny because would leave 1 or 0 cards and not creating BIRIBA and no existing BIRIBA
                    return { 
                        allowed: false, 
                        error: `Cannot create meld: After receiving biribaki, you need at least 2 cards remaining unless creating a BIRIBA (7+ cards) or you already have a BIRIBA meld. This meld would leave you with ${remainingCards} card${remainingCards === 1 ? '' : 's'}.`
                    };
                }
            }
            
            // Would leave 2+ cards, allow the meld
            return { allowed: true };
        }

        // Helper function to check if current player can extend a meld
        function canPlayerExtendMeld(meldData) {
            if (!meldData || !meldData.ownerPlayer) {
                return false; // Invalid meld data
            }
            
            const currentPlayerTeam = getPlayerTeam(gameState.currentPlayerView);
            const meldOwnerTeam = getPlayerTeam(meldData.ownerPlayer);
            
            return currentPlayerTeam === meldOwnerTeam;
        }

        // Add set to the current player's designated play area
        function addSetToPlayArea(set) {
            // Play meld success sound for all sets
            playMeldSuccessSound();
            
            // Play success sound if this is a biriba (7+ cards)
            if (set.length >= 7) {
                playSuccessSound();
            }
            const playerArea = getCurrentPlayerMeldArea();
            
            // Set up the area for melds if this is the first meld
            if (playerArea.children.length === 0) {
                playerArea.style.flexDirection = 'row';
                playerArea.style.alignItems = 'flex-start';
                playerArea.style.justifyContent = 'flex-start';
                playerArea.style.padding = '15px';
                playerArea.style.flexWrap = 'wrap';
                playerArea.style.gap = '10px';
            }
            
            // Store meld data for extension with owner information
            const meldId = `meld_${Date.now()}_${Math.random()}`;
            const meldData = {
                id: meldId,
                type: 'set',
                data: set,
                ownerPlayer: gameState.currentPlayerView // Track which player created this meld
            };
            gameState.playerMelds.push(meldData);
            
            // Create set display container
            const setDisplay = document.createElement('div');
            setDisplay.className = 'run-display'; // Reuse run display styles
            setDisplay.dataset.meldId = meldId;
            
            // Reduce height for BIRIBA sets (7+ cards)
            if (set.length >= 7) {
                setDisplay.style.minHeight = '90px'; // scaled for larger cards
                setDisplay.style.paddingBottom = '0px';
            }
            
            // Add set info - show c/d + accurate score
            const setInfo = document.createElement('div');
            setInfo.className = 'run-info';
            const status = set.isClean ? 'c' : 'd';
            const scoreData = calculateMeldScore(set, 'set');
            setInfo.textContent = `${status} + ${scoreData.totalScore}`;
            setDisplay.appendChild(setInfo);
            
            // Create cards stack container
            const cardsStack = document.createElement('div');
            cardsStack.className = 'run-cards-stack';
            
            // Order naturals first, wild last
            const sortedCards = orderSetCardsForDisplay(set);
            
            // Add cards to stack with proper positioning (highest card on top)
            sortedCards.forEach((card, index) => {
                const setCard = document.createElement('div');
                setCard.className = `run-card ${card.suit}`;
                
                // Position cards with increased offset (match ~55% size bump)
                const topOffset = index * (window.innerWidth <= 768 ? 18 : 26); // responsive offset
                const zIndex = sortedCards.length - index; // First card has highest z-index
                
                setCard.style.top = `${topOffset}px`;
                setCard.style.zIndex = zIndex;
                
                // Check if this is the last card (bottom of stack)
                const isLastCard = index === sortedCards.length - 1;
                const isBiriba = sortedCards.length >= 7;
                
                // Add margin-top to all cards to move them closer to description
                setCard.style.marginTop = '-20px';
                
                // Make last card just a tiny bit bigger and position it lower
                if (isLastCard) {
                    setCard.style.width = '78px';
                    setCard.style.height = '116px';
                    
                    // Special handling for BIRIBA sets (7+ cards)
                    if (isBiriba) {
                        // Rotate the last card horizontally and center it properly
                        setCard.style.transform = 'translateX(-50%) rotate(90deg)';
                        setCard.style.transformOrigin = 'center';
                        // Position and margin for horizontal last card
                        setCard.style.top = `${topOffset + (window.innerWidth <= 768 ? 16 : 24)}px`;
                        setCard.style.marginTop = '-19px';
                    } else {
                        // For non-BIRIBA sets, keep the normal centering transform and positioning (scaled)
                        setCard.style.top = `${topOffset + (window.innerWidth <= 768 ? 1 : 13)}px`; // Bring it down just a bit
                        setCard.style.marginTop = '9px'; // Add extra margin for non-BIRIBA sets
                    }
                } else {
                    setCard.style.width = '78px';
                    setCard.style.height = '113px';
                }
                
                // Use background image for card display
                if (card.imagePath) {
                    let imagePath;
                    if (isLastCard) {
                        // Use full card image for last card
                        imagePath = card.imagePath;
                    } else {
                        // Use cropped version for all other cards
                        imagePath = card.imagePath.replace('.png', '_cropped.png');
                    }
                    
                    setCard.style.backgroundImage = `url("${imagePath}")`;
                    setCard.style.backgroundSize = 'contain';
                    setCard.style.backgroundPosition = 'center';
                    setCard.style.backgroundRepeat = 'no-repeat';
                } else {
                    // Fallback to text display
                    if (card.suit === 'joker') {
                        setCard.textContent = 'JOKER';
                    } else {
                        const suitSymbol = getSuitSymbol(card.suit);
                        setCard.textContent = card.rank + suitSymbol;
                    }
                }
                
                cardsStack.appendChild(setCard);
            });
            
            // Set the height of the stack container based on number of cards with reduced offsets
            let stackHeight = (window.innerWidth <= 768 ? 98 : 130) + (sortedCards.length - 1) * (window.innerWidth <= 768 ? 18 : 26); // responsive height
            
            // Reduce height by 20px for BIRIBA sets (7+ cards)
            if (sortedCards.length >= 7) {
                stackHeight -= 30;
            }
            
            cardsStack.style.height = `${stackHeight}px`;
            
            setDisplay.appendChild(cardsStack);
            playerArea.appendChild(setDisplay);
        }
        
        // Display set information with custom popup
        function displaySetInfo(set) {
            const setDesc = set.cards.map(card => {
                if (isWildForSet(card, set.rank)) {
                    return `${card.rank}(as ${set.rank})`;
                } else {
                    return card.rank;
                }
            }).join('-');
            
            const flags = [];
            if (set.isClean) flags.push('CLEAN');
            if (set.isBiriba) flags.push('BIRIBA');
            
            const message = `Created set: ${setDesc}\nRank: ${set.rank}\nLength: ${set.length}\nFlags: ${flags.join(', ') || 'None'}`;
            showPopup('Set Created!', message, false);
        }
        
        // Test function to verify JavaScript is working
        function testFunction() {
            console.log('Test function called - JavaScript is working!');
            alert('Test function called - JavaScript is working!');
        }
        
        // Update meld buttons state based on turn phase
        function updateMeldButtonsState() {
            const createRunBtn = document.getElementById('create-run-btn');
            const createSetBtn = document.getElementById('create-set-btn');
            const extendMeldBtn = document.getElementById('extend-meld-btn');
            
            const canCreateMelds = gameState.turnPhase === 'melding';
            
            // Enable/disable buttons
            createRunBtn.disabled = !canCreateMelds;
            createSetBtn.disabled = !canCreateMelds;
            extendMeldBtn.disabled = !canCreateMelds;
            
            // Update visual appearance
            if (canCreateMelds) {
                createRunBtn.classList.remove('disabled');
                createSetBtn.classList.remove('disabled');
                extendMeldBtn.classList.remove('disabled');
            } else {
                createRunBtn.classList.add('disabled');
                createSetBtn.classList.add('disabled');
                extendMeldBtn.classList.add('disabled');
            }
        }

        // Create run from selected cards
        function createRunFromSelected() {
            if (loginState.isSpectator) {
                showPopup('Spectator', 'Spectators cannot perform actions.', true);
                return;
            }
            // Check if it's the current player's turn using the actual logged-in player ID
            if (gameState.currentTurn !== loginState.myPlayerId) {
                showPopup('Not Your Turn', `It's Player ${gameState.currentTurn}'s turn. You cannot create melds.`, true);
                return;
            }
            
            // Check if meld creation is allowed
            if (gameState.turnPhase !== 'melding') {
                showPopup('Cannot Create Meld', 'You must draw a card before creating melds.', true);
                return;
            }
            
            try {
                console.log('createRunFromSelected called');
                console.log('Selected cards:', gameState.selectedCards);
                console.log('Player hand:', gameState.playerHand);
                
                if (gameState.selectedCards.length === 0) {
                    console.log('No cards selected');
                    showPopup('No Cards Selected', 'Please select cards to create a run', true);
                    return;
                }
                
                // Get selected card objects with better error handling
                const selectedCardObjects = [];
                for (const cardId of gameState.selectedCards) {
                    const card = gameState.playerHand.find(c => c && c.id === cardId);
                    if (card && card.rank && card.suit && card.id) {
                        selectedCardObjects.push(card);
                    } else {
                        console.error('Invalid card found:', card, 'for cardId:', cardId);
                        console.log('Available card IDs in hand:', gameState.playerHand.map(c => c.id));
                        console.log('Selected card IDs:', gameState.selectedCards);
                        showPopup('Error', 'Card selection is out of sync. Please reselect your cards.', true);
                        // Clear selected cards to force reselection
                        gameState.selectedCards = [];
                        renderHand();
                        return;
                    }
                }
                
                console.log('Selected card objects:', selectedCardObjects);
                
                // Validate all cards have required properties
                for (const card of selectedCardObjects) {
                    if (!card || !card.rank || !card.suit || !card.id) {
                        console.error('Card missing required properties:', card);
                        showPopup('Error', 'Card data is incomplete. Please try again.', true);
                        return;
                    }
                }
                
                const runResult = tryCreateRun(selectedCardObjects);
                console.log('Run result:', runResult);
                
                if (!runResult || !runResult.valid) {
                    const errorMsg = runResult ? runResult.error : 'Unknown error occurred';
                    console.log('Invalid run:', errorMsg);
                    showPopup('Invalid Run', `Cannot create run: ${errorMsg}`, true);
                    return;
                }
                
                console.log('Valid run created, proceeding...');
                
                // Validate run result has required properties
                if (!runResult.cards || !Array.isArray(runResult.cards)) {
                    console.error('Invalid run result - missing cards array:', runResult);
                    showPopup('Error', 'Invalid run result. Please try again.', true);
                    return;
                }
                
                // Check biribaki meld restriction
                const biribakiCheck = canCreateMeldAfterBiribaki(runResult.cards.length, runResult.isBiriba);
                if (!biribakiCheck.allowed) {
                    console.log('Biribaki restriction violated:', biribakiCheck.error);
                    showPopup('Cannot Create Run', biribakiCheck.error, true);
                    return;
                }
                
                // Remove cards from hand using centralized function
                runResult.cards.forEach(card => {
                    if (!card || !card.id) {
                        console.error('Invalid card in run result:', card);
                        return;
                    }
                    
                    const index = gameState.playerHand.findIndex(c => c && c.id === card.id);
                    if (index !== -1) {
                        gameState.playerHand.splice(index, 1);
                    }
                    
                    // Remove from selected
                    const selectedIndex = gameState.selectedCards.indexOf(card.id);
                    if (selectedIndex !== -1) {
                        gameState.selectedCards.splice(selectedIndex, 1);
                    }
                });
                
                // Update hand and check for biribaki distribution using centralized function
                updatePlayerHand(gameState.currentPlayerView);
                
                // Add run to player's meld area
                addRunToPlayArea(runResult);
                
                // Update total score
                updateTotalScore();
                
                // Send meld creation to server for other players (Phase 6: Multiplayer Meld Sync)
                const cardStrings = runResult.cards.map(card => cardToString(card)).filter(str => str !== null);
                socket.emit('action', { 
                    type: 'meldCreate', 
                    kind: 'run', 
                    cards: cardStrings 
                });
                console.log('Run creation action sent to server:', { type: 'meldCreate', kind: 'run', cards: cardStrings });
                
                // Check for biribaki distribution after meld creation
                const biribakiResult = checkForBiribakiDistribution(loginState.myPlayerId);
                if (biribakiResult && biribakiResult.needsSync) {
                    console.log('SENDING BIRIBAKI PREVIEW ACTION TO SERVER...');
                    socket.emit('action', { 
                        type: 'biribakiPreview', 
                        playerId: biribakiResult.playerId,
                        team: biribakiResult.team
                    });
                    console.log(`Biribaki preview action sent to server: Player ${biribakiResult.playerId}, Team ${biribakiResult.team}`);
                }
                
                // Show success popup
                displayRunInfo(runResult);
                
                // Re-render hand
                renderHand();
            } catch (error) {
                console.error('Error in createRunFromSelected:', error);
                console.error('Error stack:', error.stack);
                showPopup('Error', `An error occurred: ${error.message}`, true);
            }
        }
        
        // Add run to the current player's designated play area
        function addRunToPlayArea(run) {
            // Play meld success sound for all runs
            playMeldSuccessSound();
            
            // Play success sound if this is a biriba (7+ cards)
            if (run.length >= 7) {
                playSuccessSound();
            }
            const playerArea = getCurrentPlayerMeldArea();
            
            // Set up the area for runs if this is the first meld
            if (playerArea.children.length === 0) {
                playerArea.style.flexDirection = 'row';
                playerArea.style.alignItems = 'flex-start';
                playerArea.style.justifyContent = 'flex-start';
                playerArea.style.padding = '15px';
                playerArea.style.flexWrap = 'wrap';
                playerArea.style.gap = '10px';
            }
            
            // Store meld data for extension with owner information
            const meldId = `meld_${Date.now()}_${Math.random()}`;
            const meldData = {
                id: meldId,
                type: 'run',
                data: run,
                ownerPlayer: gameState.currentPlayerView // Track which player created this meld
            };
            gameState.playerMelds.push(meldData);
            
            // Create run display container
            const runDisplay = document.createElement('div');
            runDisplay.className = 'run-display';
            runDisplay.dataset.meldId = meldId;
            
            // Reduce height for BIRIBA runs (7+ cards)
            if (run.length >= 7) {
                runDisplay.style.minHeight = '90px'; // scaled for larger cards
                runDisplay.style.paddingBottom = '0px';
            }
            
            // Add run info - show c/d + accurate score
            const runInfo = document.createElement('div');
            runInfo.className = 'run-info';
            const status = run.isClean ? 'c' : 'd';
            const scoreData = calculateMeldScore(run, 'run');
            runInfo.textContent = `${status} + ${scoreData.totalScore}`;
            runDisplay.appendChild(runInfo);
            
            // Create cards stack container
            const cardsStack = document.createElement('div');
            cardsStack.className = 'run-cards-stack';
            
            // Get rank value function based on orientation
            const getRankValue = run.orientation === 'LOW' ? getRankValueLow : getRankValueHigh;
            
            // Order cards using assigned ranks (wilds fill gaps / extend)
            const sortedCards = orderRunCardsForDisplay(run);
            
            // Add cards to stack with proper positioning (highest card on top)
            sortedCards.forEach((card, index) => {
                const runCard = document.createElement('div');
                runCard.className = `run-card ${card.suit}`;
                
                // Position cards with increased offset (match ~55% size bump)
                const topOffset = index * (window.innerWidth <= 768 ? 18 : 26); // responsive offset
                const zIndex = sortedCards.length - index; // Lowest card has highest z-index
                
                runCard.style.top = `${topOffset}px`;
                runCard.style.zIndex = zIndex;
                
                // Check if this is the last card (highest rank, bottom of stack)
                const isLastCard = index === sortedCards.length - 1;
                const isBiriba = sortedCards.length >= 7;
                
                // Add margin-top to all cards to move them closer to description
                runCard.style.marginTop = '-20px';
                
                // Make last card just a tiny bit bigger and position it lower
                if (isLastCard) {
                    runCard.style.width = '78px';
                    runCard.style.height = '116px';
                    
                // Special handling for BIRIBA runs (7+ cards)
                if (isBiriba) {
                    // Rotate the last card horizontally and center it properly
                    runCard.style.transform = 'translateX(-50%) rotate(90deg)';
                    runCard.style.transformOrigin = 'center';
                    // Position and margin for horizontal last card
                    runCard.style.top = `${topOffset + (window.innerWidth <= 768 ? 16 : 24)}px`;
                    runCard.style.marginTop = '-19px';
                } else {
                    // For non-BIRIBA runs, keep the normal centering transform and positioning (scaled)
                    runCard.style.top = `${topOffset + (window.innerWidth <= 768 ? 1 : 13)}px`; // Bring it down just a bit
                    runCard.style.marginTop = '9px'; // Add extra margin for non-BIRIBA runs
                }
                } else {
                    runCard.style.width = '78px';
                    runCard.style.height = '113px';
                }
                
                // Use background image for card display
                if (card.imagePath) {
                    let imagePath;
                    if (isLastCard) {
                        // Use full card image for last card
                        imagePath = card.imagePath;
                    } else {
                        // Use cropped version for all other cards
                        imagePath = card.imagePath.replace('.png', '_cropped.png');
                    }
                    
                    runCard.style.backgroundImage = `url("${imagePath}")`;
                    runCard.style.backgroundSize = 'contain';
                    runCard.style.backgroundPosition = 'center';
                    runCard.style.backgroundRepeat = 'no-repeat';
                    
                    // Wild indicator removed - no yellow box on wild cards
                } else {
                    // Fallback to text display
                    if (card.suit === 'joker') {
                        runCard.textContent = 'JOKER';
                    } else {
                        const suitSymbol = getSuitSymbol(card.suit);
                        runCard.textContent = card.rank + suitSymbol;
                    }
                }
                
                cardsStack.appendChild(runCard);
            });
            
            // Set the height of the stack container based on number of cards with reduced offsets
            let stackHeight = (window.innerWidth <= 768 ? 98 : 130) + (sortedCards.length - 1) * (window.innerWidth <= 768 ? 18 : 26); // responsive height
            
            // Reduce height by 20px for BIRIBA runs (7+ cards)
            if (sortedCards.length >= 7) {
                stackHeight -= 30;
            }
            
            cardsStack.style.height = `${stackHeight}px`;
            
            runDisplay.appendChild(cardsStack);
            playerArea.appendChild(runDisplay);
        }
        
        // Show custom popup
        function showPopup(title, message, isError = false) {
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            
            // Create popup
            const popup = document.createElement('div');
            popup.className = 'popup';
            
            // Add title
            const titleElement = document.createElement('h3');
            titleElement.textContent = title;
            popup.appendChild(titleElement);
            
            // Add message
            const messageElement = document.createElement('p');
            messageElement.textContent = message;
            popup.appendChild(messageElement);
            
            // Add button
            const button = document.createElement('button');
            button.className = isError ? 'popup-btn error' : 'popup-btn';
            button.textContent = 'OK';
            button.onclick = () => {
                document.body.removeChild(overlay);
            };
            popup.appendChild(button);
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            // Focus the button for keyboard accessibility
            button.focus();
        }

        // Show game instructions
        function showGameInstructions() {
            // Create custom styled popup for instructions
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            overlay.style.zIndex = '10000';
            
            const popup = document.createElement('div');
            popup.className = 'instructions-popup';
            popup.innerHTML = `
                <div class="instructions-header">
                    <h2> How to Play Biriba</h2>
                    <button class="close-btn" onclick="this.closest('.popup-overlay').remove()"></button>
                </div>
                
                <div class="instructions-content">
                    <div class="instruction-section">
                        <h3> Teams</h3>
                        <div class="team-info">
                            <div class="team"><span class="team-color team1"></span> Team 1: Players 1 & 3</div>
                            <div class="team"><span class="team-color team2"></span> Team 2: Players 2 & 4</div>
                        </div>
                    </div>
                    
                    <div class="instruction-section">
                        <h3> Your Turn</h3>
                        <div class="turn-steps">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div class="step-content">
                                    <strong>DRAW</strong> (pick one):
                                    <ul>
                                        <li>Draw from the stock pile (face-down deck)</li>
                                        <li>OR pick up the entire discard pile</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <div class="step">
                                <span class="step-number">2</span>
                                <div class="step-content">
                                    <strong>MELD</strong> (optional):
                                    <ul>
                                        <li><strong>Sets:</strong> 3+ cards of same rank <span class="example">(7, 7, 7)</span></li>
                                        <li><strong>Runs:</strong> 3+ consecutive cards of same suit <span class="example">(4, 5, 6)</span></li>
                                        <li>Extend existing melds by adding cards</li>
                                        <li>Jokers can substitute for any card</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <div class="step">
                                <span class="step-number">3</span>
                                <div class="step-content">
                                    <strong>DISCARD:</strong>
                                    <ul>
                                        <li>Drag a card from your hand to the discard pile</li>
                                        <li>This ends your turn</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            // Add CSS for the instructions popup
            if (!document.getElementById('instructions-styles')) {
                const style = document.createElement('style');
                style.id = 'instructions-styles';
                style.textContent = `
                    .instructions-popup {
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        border-radius: 20px;
                        padding: 0;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                        position: relative;
                    }
                    
                    .instructions-header {
                        background: rgba(255, 255, 255, 0.1);
                        padding: 20px;
                        border-radius: 20px 20px 0 0;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        border-bottom: 2px solid rgba(255, 255, 255, 0.2);
                    }
                    
                    .instructions-header h2 {
                        color: white;
                        margin: 0;
                        font-size: 24px;
                        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                    }
                    
                    .close-btn {
                        background: rgba(255, 255, 255, 0.2);
                        border: none;
                        color: white;
                        font-size: 24px;
                        width: 40px;
                        height: 40px;
                        border-radius: 50%;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.3s ease;
                    }
                    
                    .close-btn:hover {
                        background: rgba(255, 255, 255, 0.3);
                        transform: scale(1.1);
                    }
                    
                    .instructions-content {
                        padding: 30px;
                        color: white;
                    }
                    
                    .instruction-section {
                        margin-bottom: 25px;
                    }
                    
                    .instruction-section h3 {
                        color: #FFD700;
                        font-size: 18px;
                        margin: 0 0 15px 0;
                        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                    }
                    
                    .team-info {
                        display: flex;
                        gap: 20px;
                        flex-wrap: wrap;
                    }
                    
                    .team {
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        background: rgba(255, 255, 255, 0.1);
                        padding: 10px 15px;
                        border-radius: 10px;
                        font-weight: bold;
                    }
                    
                    .team-color {
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        border: 2px solid white;
                    }
                    
                    .team-color.team1 {
                        background: #FF6B6B;
                    }
                    
                    .team-color.team2 {
                        background: #4ECDC4;
                    }
                    
                    .turn-steps {
                        display: flex;
                        flex-direction: column;
                        gap: 15px;
                    }
                    
                    .step {
                        display: flex;
                        gap: 15px;
                        align-items: flex-start;
                    }
                    
                    .step-number {
                        background: #FFD700;
                        color: #333;
                        width: 30px;
                        height: 30px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 16px;
                        flex-shrink: 0;
                    }
                    
                    .step-content {
                        flex: 1;
                    }
                    
                    .step-content ul {
                        margin: 8px 0 0 0;
                        padding-left: 20px;
                    }
                    
                    .step-content li {
                        margin: 5px 0;
                        line-height: 1.4;
                    }
                    
                    .example {
                        color: #FFD700;
                        font-style: italic;
                    }
                    
                    .winning-info p {
                        background: rgba(255, 255, 255, 0.1);
                        padding: 15px;
                        border-radius: 10px;
                        margin: 10px 0;
                        line-height: 1.5;
                    }
                    
                    .controls-info {
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                    }
                    
                    .control-item {
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        background: rgba(255, 255, 255, 0.1);
                        padding: 12px 15px;
                        border-radius: 10px;
                    }
                    
                    .control-icon {
                        font-size: 20px;
                        width: 30px;
                        text-align: center;
                    }
                    
                    @media (max-width: 600px) {
                        .instructions-popup {
                            width: 95%;
                            margin: 10px;
                        }
                        
                        .instructions-content {
                            padding: 20px;
                        }
                        
                        .team-info {
                            flex-direction: column;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Display run information with custom popup
        function displayRunInfo(run) {
            const runDesc = run.cards.map(card => {
                if (isWild(card, run.cards, run.suit)) {
                    const assignedRank = run.wildMap ? run.wildMap.get(card.id) : undefined;
                    if (assignedRank !== undefined && assignedRank !== null) {
                        const assignedRankStr = rankValueToString(assignedRank, run.orientation);
                        return `${card.rank}(as ${assignedRankStr})`;
                    } else {
                        // Fallback if no assigned rank found
                        return `${card.rank}(as ?)`;
                    }
                } else {
                    return card.rank;
                }
            }).join('-');
            
            const suitSymbol = getSuitSymbol(run.suit);
            const flags = [];
            if (run.isClean) flags.push('CLEAN');
            if (run.isBiriba) flags.push('BIRIBA');
            
            const message = `Created ${run.orientation} run: ${runDesc}${suitSymbol}\nLength: ${run.length}\nFlags: ${flags.join(', ') || 'None'}`;
            showPopup('Run Created!', message, false);
        }

        // Toggle extend meld mode
        function toggleExtendMeldMode() {
            // Check if it's the current player's turn using the actual logged-in player ID
            if (gameState.currentTurn !== loginState.myPlayerId) {
                showPopup('Not Your Turn', `It's Player ${gameState.currentTurn}'s turn. You cannot extend melds.`, true);
                return;
            }
            
            // Check if meld creation is allowed
            if (gameState.turnPhase !== 'melding') {
                showPopup('Cannot Extend Meld', 'You must draw a card before extending melds.', true);
                return;
            }
            
            gameState.extendMeldMode = !gameState.extendMeldMode;
            const extendBtn = document.getElementById('extend-meld-btn');
            
            if (gameState.extendMeldMode) {
                extendBtn.classList.add('active');
                extendBtn.textContent = 'Cancel Extend';
                showPopup('Extend Meld Mode', 'Select cards from your hand, then click on a meld to extend it.', false);
                
                // Make melds clickable
                enableMeldClicking();
            } else {
                extendBtn.classList.remove('active');
                extendBtn.textContent = 'Extend Meld';
                
                // Disable meld clicking
                disableMeldClicking();
            }
        }
        
        // Enable clicking on melds for extension
        function enableMeldClicking() {
            const meldDisplays = document.querySelectorAll('.run-display[data-meld-id]');
            meldDisplays.forEach(meldDisplay => {
                meldDisplay.style.cursor = 'pointer';
                meldDisplay.style.border = '2px solid #9b59b6';
                meldDisplay.addEventListener('click', handleMeldClick);
            });
        }
        
        // Disable clicking on melds
        function disableMeldClicking() {
            const meldDisplays = document.querySelectorAll('.run-display[data-meld-id]');
            meldDisplays.forEach(meldDisplay => {
                meldDisplay.style.cursor = 'default';
                meldDisplay.style.border = '2px solid #FFD700';
                meldDisplay.removeEventListener('click', handleMeldClick);
            });
        }
        
        // Handle clicking on a meld to extend it
        function handleMeldClick(event) {
            if (!gameState.extendMeldMode) return;
            
            const meldDisplay = event.currentTarget;
            const meldId = meldDisplay.dataset.meldId;
            
            if (!meldId) {
                console.error('No meld ID found');
                return;
            }
            
            // Find the meld data
            const meldData = gameState.playerMelds.find(m => m.id === meldId);
            if (!meldData) {
                console.error('Meld data not found for ID:', meldId);
                showPopup('Error', 'Could not find meld data. Please try again.', true);
                return;
            }
            
            // Check team ownership - only allow extending melds from same team
            if (!canPlayerExtendMeld(meldData)) {
                const currentPlayerTeam = getPlayerTeam(gameState.currentPlayerView);
                const meldOwnerTeam = getPlayerTeam(meldData.ownerPlayer);
                showPopup('Cannot Extend Meld', `This meld belongs to Team ${meldOwnerTeam}. Only Team ${meldOwnerTeam} players can extend it. You are on Team ${currentPlayerTeam}.`, true);
                return;
            }
            
            // Check if cards are selected
            if (gameState.selectedCards.length === 0) {
                showPopup('No Cards Selected', 'Please select cards from your hand to extend this meld.', true);
                return;
            }
            
            // Attempt to extend the meld
            extendMeld(meldData, meldDisplay);
        }
        
        // Extend a meld with selected cards
        function extendMeld(meldData, meldDisplay) {
            if (loginState.isSpectator) {
                showPopup('Spectator', 'Spectators cannot perform actions.', true);
                return;
            }
            try {
                console.log('Extending meld:', meldData);
                console.log('Selected cards:', gameState.selectedCards);
                
                // Get selected card objects
                const selectedCardObjects = [];
                for (const cardId of gameState.selectedCards) {
                    const card = gameState.playerHand.find(c => c && c.id === cardId);
                    if (card && card.rank && card.suit && card.id) {
                        selectedCardObjects.push(card);
                    } else {
                        console.error('Invalid card found:', card, 'for cardId:', cardId);
                        console.log('Available card IDs in hand:', gameState.playerHand.map(c => c.id));
                        console.log('Selected card IDs:', gameState.selectedCards);
                        showPopup('Error', 'Card selection is out of sync. Please reselect your cards.', true);
                        // Clear selected cards to force reselection
                        gameState.selectedCards = [];
                        renderHand();
                        return;
                    }
                }
                
                // Combine existing meld cards with selected cards
                const existingCards = meldData.data.cards;
                const allCards = [...existingCards, ...selectedCardObjects];
                
                console.log('All cards for extension:', allCards);
                
                // Try to create extended meld based on original type with stricter validation for sets
                let extendedResult;
                if (meldData.type === 'run') {
                    extendedResult = tryCreateRun(allCards);
                } else if (meldData.type === 'set') {
                    extendedResult = tryExtendSet(meldData.data, selectedCardObjects);
                } else {
                    showPopup('Error', 'Unknown meld type. Cannot extend.', true);
                    return;
                }
                
                console.log('Extended result:', extendedResult);
                
                if (!extendedResult || !extendedResult.valid) {
                    const errorMsg = extendedResult ? extendedResult.error : 'Unknown error occurred';
                    console.log('Invalid extension:', errorMsg);
                    showPopup('Cannot Extend Meld', `Cannot extend meld: ${errorMsg}`, true);
                    return;
                }
                
                // Check biribaki meld restriction for extending melds
                const biribakiCheck = canCreateMeldAfterBiribaki(selectedCardObjects.length, extendedResult.isBiriba);
                if (!biribakiCheck.allowed) {
                    console.log('Biribaki restriction violated for meld extension:', biribakiCheck.error);
                    showPopup('Cannot Extend Meld', biribakiCheck.error, true);
                    return;
                }
                
                // Remove selected cards from hand using centralized function
                selectedCardObjects.forEach(card => {
                    const index = gameState.playerHand.findIndex(c => c && c.id === card.id);
                    if (index !== -1) {
                        gameState.playerHand.splice(index, 1);
                    }
                    
                    // Remove from selected
                    const selectedIndex = gameState.selectedCards.indexOf(card.id);
                    if (selectedIndex !== -1) {
                        gameState.selectedCards.splice(selectedIndex, 1);
                    }
                });
                
                // Update hand and check for biribaki distribution using centralized function
                updatePlayerHand(gameState.currentPlayerView);
                
                // Remove old meld from display and data
                meldDisplay.remove();
                const meldIndex = gameState.playerMelds.findIndex(m => m.id === meldData.id);
                if (meldIndex !== -1) {
                    gameState.playerMelds.splice(meldIndex, 1);
                }
                
                // Add new extended meld
                if (meldData.type === 'run') {
                    addRunToPlayArea(extendedResult);
                    displayRunInfo(extendedResult);
                } else {
                    addSetToPlayArea(extendedResult);
                    displaySetInfo(extendedResult);
                }
                
                // Exit extend mode
                toggleExtendMeldMode();
                
                // Update total score
                updateTotalScore();
                
                console.log('Meld extended successfully');
                
            } catch (error) {
                console.error('Error in extendMeld:', error);
                console.error('Error stack:', error.stack);
                showPopup('Error', `An error occurred: ${error.message}`, true);
            }
        }


        // Show discard pile popup with all cards
        function showDiscardPilePopup() {
            if (gameState.discardPile.length === 0) {
                showPopup('Discard Pile', 'No cards have been discarded yet.', false);
                return;
            }
            
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            
            // Create popup with larger size for card display
            const popup = document.createElement('div');
            popup.className = 'popup';
            popup.style.maxWidth = '600px';
            popup.style.maxHeight = '80vh';
            popup.style.overflow = 'auto';
            
            // Add title
            const titleElement = document.createElement('h3');
            titleElement.textContent = `Discard Pile (${gameState.discardPile.length} cards)`;
            popup.appendChild(titleElement);
            
            // Create cards container
            const cardsContainer = document.createElement('div');
            cardsContainer.style.display = 'flex';
            cardsContainer.style.flexWrap = 'wrap';
            cardsContainer.style.gap = '8px';
            cardsContainer.style.justifyContent = 'center';
            cardsContainer.style.margin = '20px 0';
            cardsContainer.style.maxHeight = '400px';
            cardsContainer.style.overflowY = 'auto';
            cardsContainer.style.padding = '10px';
            cardsContainer.style.background = 'rgba(0, 0, 0, 0.1)';
            cardsContainer.style.borderRadius = '8px';
            
            // Show cards in reverse order (newest first)
            const reversedPile = [...gameState.discardPile].reverse();
            
            reversedPile.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.style.width = '60px';
                cardElement.style.height = '90px';
                cardElement.style.borderRadius = '6px';
                cardElement.style.border = '2px solid rgba(255, 255, 255, 0.3)';
                cardElement.style.position = 'relative';
                cardElement.style.cursor = 'pointer';
                cardElement.style.transition = 'transform 0.2s ease';
                cardElement.title = `${card.rank}${getSuitSymbol(card.suit)} (${gameState.discardPile.length - index} cards ago)`;
                
                // Add hover effect
                cardElement.addEventListener('mouseenter', () => {
                    cardElement.style.transform = 'scale(1.1)';
                    cardElement.style.zIndex = '10';
                });
                cardElement.addEventListener('mouseleave', () => {
                    cardElement.style.transform = 'scale(1)';
                    cardElement.style.zIndex = '1';
                });
                
                // Use card image if available
                if (card.imagePath) {
                    cardElement.style.backgroundImage = `url("${card.imagePath}")`;
                    cardElement.style.backgroundSize = 'contain';
                    cardElement.style.backgroundPosition = 'center';
                    cardElement.style.backgroundRepeat = 'no-repeat';
                } else {
                    // Fallback to text display
                    cardElement.style.display = 'flex';
                    cardElement.style.alignItems = 'center';
                    cardElement.style.justifyContent = 'center';
                    cardElement.style.fontSize = '10px';
                    cardElement.style.fontWeight = 'bold';
                    cardElement.style.background = 'white';
                    
                    if (card.suit === 'joker') {
                        cardElement.textContent = 'JOKER';
                        cardElement.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ffd93d 50%, #ff6b6b 100%)';
                        cardElement.style.color = '#333';
                    } else {
                        const suitSymbol = getSuitSymbol(card.suit);
                        cardElement.textContent = card.rank + suitSymbol;
                        if (card.suit === 'hearts' || card.suit === 'diamonds') {
                            cardElement.style.color = '#dc143c';
                        } else {
                            cardElement.style.color = '#2c2c2c';
                        }
                    }
                }
                
                cardsContainer.appendChild(cardElement);
            });
            
            popup.appendChild(cardsContainer);
            
            // Add close button
            const button = document.createElement('button');
            button.className = 'popup-btn';
            button.textContent = 'Close';
            button.onclick = () => {
                document.body.removeChild(overlay);
            };
            popup.appendChild(button);
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            // Focus the button for keyboard accessibility
            button.focus();
            
            // Close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }

        // Discard selected cards function
        function discardSelectedCards() {
            if (gameState.selectedCards.length === 0) {
                showPopup('No Cards Selected', 'Please select a card to discard.', true);
                return;
            }
            
            if (gameState.selectedCards.length > 1) {
                showPopup('Too Many Cards Selected', 'Please select only one card to discard.', true);
                return;
            }
            
            // Discard the single selected card
            const cardId = gameState.selectedCards[0];
            discardCard(cardId);
        }

        // End game function - called when a team wins by going out after biribaki
        function endGame(winningTeam) {
            console.log(`Game ended! Team ${winningTeam} wins!`);
            playGameEndSound();
            
            // Calculate current team scores
            const teamScores = calculateTeamScores();
            
            // Award 100-point bonus to winning team
            teamScores[winningTeam] += 100;
            
            // Check if opposing team has received their biribaki yet
            const opposingTeam = winningTeam === 1 ? 2 : 1;
            let biribakiPenaltyApplied = false;
            
            if (gameState.teamBiribakiReceived[opposingTeam] === 0) {
                // Apply -100 penalty to opposing team if they haven't received their biribaki
                teamScores[opposingTeam] -= 100;
                biribakiPenaltyApplied = true;
                console.log(`Team ${opposingTeam} penalized -100 points for not receiving biribaki`);
            }
            
            // Update the score display with final scores
            const team1ScoreElement = document.getElementById('team1-score');
            const team2ScoreElement = document.getElementById('team2-score');
            
            if (team1ScoreElement) {
                team1ScoreElement.textContent = teamScores[1];
            }
            if (team2ScoreElement) {
                team2ScoreElement.textContent = teamScores[2];
            }
            
            // Disable all game actions
            gameState.turnPhase = 'game_over';
            updateMeldButtonsState();
            updateDiscardAvailability();
            
            // Show victory popup with final scores and penalty information
            let message = ` GAME OVER! \n\nTeam ${winningTeam} WINS!\n\nFinal Scores:\nTeam 1: ${teamScores[1]} points\nTeam 2: ${teamScores[2]} points\n\n(+100 bonus points awarded to winning team)`;
            
            if (biribakiPenaltyApplied) {
                message += `\n(-100 penalty applied to Team ${opposingTeam} for not receiving biribaki)`;
            }
            
            showPopup('Victory!', message, false);
            
            console.log('Final scores:', teamScores);
            console.log('Biribaki penalty applied:', biribakiPenaltyApplied);
        }

        // Card picker overlay functionality
        let cardPickerOpen = false;

        // Toggle card picker overlay
        function toggleCardPicker() {
            // If already open, close it
            if (cardPickerOpen) {
                closeCardPicker();
                return;
            }
            
            // Prompt for password before opening
            const password = prompt('Enter password to access dev tools:');
            if (password !== 'biribaki') {
                if (password !== null) { // Only show alert if user didn't cancel
                    alert('Incorrect password. Access denied.');
                }
                return;
            }
            
            // Password correct, open the picker
            const sidebar = document.getElementById('card-picker-sidebar');
            const backdrop = document.getElementById('card-picker-backdrop');
            const toggleBtn = document.getElementById('card-picker-toggle');
            
            cardPickerOpen = true;
            
                // Show overlay
                sidebar.classList.add('active');
                backdrop.classList.add('active');
                toggleBtn.classList.add('active');
                toggleBtn.textContent = '';
            
            // Emit action to notify all players that dev tools were opened
            socket.emit('action', { 
                type: 'devToolsOpened', 
                playerId: loginState.myPlayerId
            });
        }

        // Close card picker when clicking backdrop
        function closeCardPicker() {
            if (cardPickerOpen) {
                const sidebar = document.getElementById('card-picker-sidebar');
                const backdrop = document.getElementById('card-picker-backdrop');
                const toggleBtn = document.getElementById('card-picker-toggle');
                
                cardPickerOpen = false;
                
                // Hide overlay
                sidebar.classList.remove('active');
                backdrop.classList.remove('active');
                toggleBtn.classList.remove('active');
                toggleBtn.textContent = '';
            }
        }

        // Enhanced login state management for online multiplayer
        let loginState = {
            selectedPlayer: null,
            hasJoined: false,
            takenSeats: new Set(), // Track which seats are taken by other players
            myPlayerId: null, // Track which player ID this client represents
            isHost: false, // Track if this client is the host
            isSpectator: false // Track if this client is spectating (read-only)
        };
        
        // Track all players who have joined (including self)
        let joinedPlayers = new Set();
        
        // Store player names
        let playerNames = {
            1: 'Player 1',
            2: 'Player 2', 
            3: 'Player 3',
            4: 'Player 4'
        };
        
        // Track drag state for hand reordering
        let draggedCardId = null;

        // Real multiplayer seat management with Socket.IO
        function joinAsPlayer(playerNumber) {
            console.log(`Requesting seat ${playerNumber} from server...`);
            
            // Get the player name from the input field
            const nameInput = document.getElementById(`name-input-${playerNumber}`);
            let playerName = nameInput.value.trim();
            
            // If no name provided, use default "Player X"
            if (!playerName) {
                playerName = `Player ${playerNumber}`;
            }
            
            // Limit to 16 characters as requested
            playerName = playerName.substring(0, 16);
            
            console.log(`Joining as Player ${playerNumber} with name: "${playerName}"`);
            socket.emit('requestSeat', { seat: playerNumber, playerName: playerName });
            // Exit spectator mode if active
            if (loginState.isSpectator) {
                loginState.isSpectator = false;
                socket.emit('spectateLeave');
            }
        }

        // Real multiplayer leave seat with Socket.IO
        function leaveSeat(playerNumber) {
            console.log(`Requesting to leave seat ${playerNumber}...`);
            socket.emit('leaveSeat');
        }

        // Spectator join/leave
        function joinAsSpectator() {
            loginState.isSpectator = true;
            socket.emit('spectateJoin');
            // Hide login overlay and show main UI
            const loginOverlay = document.getElementById('login-overlay');
            if (loginOverlay) loginOverlay.style.display = 'none';
            const gameContainer = document.querySelector('.game-container');
            const cardPickerToggle = document.querySelector('.card-picker-toggle');
            const cardPickerBackdrop = document.querySelector('.card-picker-backdrop');
            const cardPickerSidebar = document.querySelector('.card-picker-sidebar');
            if (gameContainer) gameContainer.style.display = 'block';
            if (cardPickerToggle) cardPickerToggle.style.display = 'flex';
            if (cardPickerBackdrop) cardPickerBackdrop.style.display = 'block';
            if (cardPickerSidebar) cardPickerSidebar.style.display = 'block';
            // Disable interactions and hide hand
            const handArea = document.getElementById('player-hand');
            if (handArea) handArea.style.display = 'none';
            const stockPile = document.getElementById('stock-pile');
            if (stockPile) stockPile.style.pointerEvents = 'none';
            const discardPile = document.getElementById('discard-pile');
            if (discardPile) discardPile.style.pointerEvents = 'none';
            // Pull current state from host to sync
            socket.emit('requestFullState');
            showPopup('Spectator', 'You are now spectating. Actions are disabled.', false);
        }

        // Host settings functions
        function toggleRandomStartingPlayer() {
            // Only allow host to access settings
            if (!loginState.isHost) {
                showPopup('Access Denied', 'Only the host can access settings.', true);
                return;
            }

            const toggle = document.getElementById('random-start-toggle');
            const info = document.getElementById('random-start-info');
            
            if (toggle.classList.contains('active')) {
                // Turn off random starting player
                toggle.classList.remove('active');
                gameState.randomStartingPlayerSkips = 0;
                info.textContent = 'Off - Game starts with Player 1';
                info.style.color = 'rgba(236, 240, 241, 0.8)';
            } else {
                // Turn on random starting player
                toggle.classList.add('active');
                // Generate random number from 0 to 3
                const randomSkips = Math.floor(Math.random() * 4);
                gameState.randomStartingPlayerSkips = randomSkips;
                
                info.textContent = 'On - Starting player will be randomized';
                info.style.color = '#FFD700';
            }
        }

        function toggleDisableSets() {
            // Only allow host to access settings
            if (!loginState.isHost) {
                showPopup('Access Denied', 'Only the host can access settings.', true);
                return;
            }

            const toggle = document.getElementById('disable-sets-toggle');
            const info = document.getElementById('disable-sets-info');
            
            if (toggle.classList.contains('active')) {
                // Turn off disable sets (enable sets)
                toggle.classList.remove('active');
                gameState.disableSets = false;
                info.textContent = 'Off - Sets are allowed';
                info.style.color = 'rgba(236, 240, 241, 0.8)';
            } else {
                // Turn on disable sets
                toggle.classList.add('active');
                gameState.disableSets = true;
                info.textContent = 'On - Sets are disabled';
                info.style.color = '#FFD700';
            }
            
            // Update the create set button visibility
            updateCreateSetButtonVisibility();
        }

        // Show/hide host settings bar based on host status
        function updateHostSettingsVisibility() {
            const settingsBar = document.getElementById('host-settings-bar');
            if (loginState.isHost) {
                settingsBar.style.display = 'block';
            } else {
                settingsBar.style.display = 'none';
            }
        }

        // Update create set button visibility based on disableSets setting
        function updateCreateSetButtonVisibility() {
            const createSetBtn = document.getElementById('create-set-btn');
            if (createSetBtn) {
                if (gameState.disableSets) {
                    createSetBtn.style.display = 'none';
                } else {
                    createSetBtn.style.display = 'block';
                }
            }
        }

        // Set atou biriba value
        // Set run base value
        function setRunBaseValue(value) {
            // Only allow host to access settings
            if (!loginState.isHost) {
                showPopup('Access Denied', 'Only the host can access settings.', true);
                return;
            }

            gameState.runBaseValue = value;
            updateRunBaseValueDisplay();
        }

        // Update run base value display
        function updateRunBaseValueDisplay() {
            const value = gameState.runBaseValue;
            
            // Update button states
            document.querySelectorAll('#run-base-1000, #run-base-2000').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(`run-base-${value}`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            // Update info text
            const info = document.getElementById('run-base-info');
            if (info) {
                const dirtyValue = Math.floor(value / 2);
                info.textContent = `Clean runs: ${value}, Dirty runs: ${dirtyValue}`;
                info.style.color = '#FFD700';
            }
        }
        function setAtouValue(value) {
            // Only allow host to access settings
            if (!loginState.isHost) {
                showPopup('Access Denied', 'Only the host can access settings.', true);
                return;
            }

            gameState.atouBiribaValue = value;
            updateAtouValueDisplay();
            updateRunBaseValueDisplay();
        }

        // Update atou value display
        function updateAtouValueDisplay() {
            const value = gameState.atouBiribaValue;
            
            // Update button states
            document.querySelectorAll('#atou-value-400, #atou-value-600').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(`atou-value-${value}`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            // Update info text
            const info = document.getElementById('atou-value-info');
            if (info) {
                const dirtyValue = Math.floor(value / 2);
                info.textContent = `Clean atou: ${value}, Dirty atou: ${dirtyValue}`;
                info.style.color = '#FFD700';
            }
        }

        // Update all slot displays based on current state
        function updateAllSlotDisplays() {
            for (let i = 1; i <= 4; i++) {
                const slot = document.querySelector(`[data-player="${i}"]`);
                if (!slot) continue;
                
                // Update slot label with custom name
                const slotLabel = slot.querySelector('.slot-label');
                if (slotLabel) {
                    slotLabel.textContent = playerNames[i];
                }
                
                // Remove all state classes
                slot.classList.remove('selected', 'taken');
                
                // Clear existing button content
                const existingButton = slot.querySelector('.join-btn, .leave-btn');
                const existingText = slot.querySelector('.seat-taken-text');
                if (existingButton) existingButton.remove();
                if (existingText) existingText.remove();
                
                if (loginState.myPlayerId === i) {
                    // This is my seat - show "Leave Seat" button
                    slot.classList.add('selected');
                    const leaveBtn = document.createElement('button');
                    leaveBtn.className = 'leave-btn';
                    leaveBtn.textContent = 'Leave Seat';
                    leaveBtn.onclick = () => leaveSeat(i);
                    slot.appendChild(leaveBtn);
                } else if (loginState.takenSeats.has(i)) {
                    // Seat is taken by someone else - show "Seat is Taken"
                    slot.classList.add('taken');
                    const takenText = document.createElement('div');
                    takenText.className = 'seat-taken-text';
                    takenText.textContent = 'Seat is Taken';
                    slot.appendChild(takenText);
                } else {
                    // Seat is available - show "Join" button
                    const joinBtn = document.createElement('button');
                    joinBtn.className = 'join-btn';
                    joinBtn.textContent = 'Join';
                    joinBtn.onclick = () => joinAsPlayer(i);
                    slot.appendChild(joinBtn);
                }
            }
            
            // Update player view buttons
            updatePlayerViewButtons();
        }
        
        // Update player view buttons with custom names
        function updatePlayerViewButtons() {
            for (let i = 1; i <= 4; i++) {
                const button = document.querySelector(`[data-player="${i}"].player-view-btn`);
                if (button) {
                    button.textContent = playerNames[i];
                }
            }
        }
        
        // Update meld area labels with custom names
        function updateMeldAreaLabels() {
            // Team 1 (Players 1&3) use player1 area
            const player1Area = document.querySelector('.meld-area.player1');
            if (player1Area) {
                player1Area.setAttribute('data-area-name', `${playerNames[1]} & ${playerNames[3]} Play Area`);
            }
            
            // Team 2 (Players 2&4) use player2 area
            const player2Area = document.querySelector('.meld-area.player2');
            if (player2Area) {
                player2Area.setAttribute('data-area-name', `${playerNames[2]} & ${playerNames[4]} Play Area`);
            }
        }

        // Simulate other players joining (for testing purposes)
        function simulatePlayerJoin(playerNumber) {
            if (loginState.myPlayerId === playerNumber) {
                console.log(`Cannot simulate join for Player ${playerNumber} - that's your seat`);
                return;
            }
            
            loginState.takenSeats.add(playerNumber);
            updateAllSlotDisplays();
            console.log(`Simulated Player ${playerNumber} joining`);
        }

        // Simulate other players leaving (for testing purposes)
        function simulatePlayerLeave(playerNumber) {
            if (loginState.myPlayerId === playerNumber) {
                console.log(`Cannot simulate leave for Player ${playerNumber} - that's your seat`);
                return;
            }
            
            loginState.takenSeats.delete(playerNumber);
            updateAllSlotDisplays();
            console.log(`Simulated Player ${playerNumber} leaving`);
        }

        // Update start game button based on host status
        function updateStartGameButton() {
            const startGameBtn = document.querySelector('.start-game-btn');
            const futureNote = document.querySelector('.future-note');
            
            if (!startGameBtn) return;
            
            if (loginState.isHost && loginState.hasJoined) {
                // Enable start game button for host
                startGameBtn.disabled = false;
                startGameBtn.style.cursor = 'pointer';
                startGameBtn.style.opacity = '1';
                startGameBtn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
                startGameBtn.textContent = 'Start Game (Host)';
                
                if (futureNote) {
                    futureNote.textContent = '* Click to start the game for all players';
                }
            } else if (loginState.hasJoined) {
                // Show waiting message for non-host players
                startGameBtn.disabled = true;
                startGameBtn.style.cursor = 'not-allowed';
                startGameBtn.style.opacity = '0.6';
                startGameBtn.style.background = 'linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%)';
                startGameBtn.textContent = 'Waiting for Host';
                
                if (futureNote) {
                    futureNote.textContent = '* Only the host can start the game';
                }
            } else {
                // Default state - no player joined
                startGameBtn.disabled = true;
                startGameBtn.style.cursor = 'not-allowed';
                startGameBtn.style.opacity = '0.6';
                startGameBtn.style.background = 'linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%)';
                startGameBtn.textContent = 'Start Game';
                
                if (futureNote) {
                    futureNote.textContent = '* Join a seat to participate';
                }
            }

            // Host-only: start broadcasting checksum periodically for resync
            if (loginState.isHost) {
                if (!window.__checksumInterval) {
                    window.__checksumInterval = setInterval(() => {
                        try {
                            const fs = gameStateToFullState();
                            const checksum = computeFullStateChecksum(fs);
                            socket.emit('stateChecksum', { checksum, ts: Date.now() });
                        } catch (e) {
                            console.error('Checksum broadcast failed:', e);
                        }
                    }, 4000);
                }
            } else {
                if (window.__checksumInterval) {
                    clearInterval(window.__checksumInterval);
                    window.__checksumInterval = null;
                }
            }
        }

        // Host-controlled game start - sends fullState to server
        function startGame() {
            if (!loginState.isHost) {
                showPopup('Not Host', 'Only the host can start the game.', true);
                return;
            }
            
            if (!loginState.hasJoined || !loginState.selectedPlayer) {
                showPopup('Not Joined', 'You must join a seat before starting the game.', true);
                return;
            }
            
            console.log('Host is starting the game...');
            
            // Create a new game state
            newGame();
            
            // Convert current gameState to fullState format
            const fullState = gameStateToFullState();
            
            console.log('Sending fullState to server:', fullState);
            
            // Send fullState to server for broadcasting
            socket.emit('startGame', { fullState: fullState });
        }

        // Start game from host (called when receiving gameStarted event)
        function startGameFromHost() {
            if (!loginState.hasJoined || !loginState.selectedPlayer) {
                console.log('Cannot start game - not joined or no player selected');
                return;
            }
            
            const playerNumber = loginState.selectedPlayer;
            console.log(`Starting game from host as Player ${playerNumber}`);
            
            // Set the player viewpoint to the selected player
            gameState.currentPlayerView = playerNumber;
            
            // Update the player hand reference to the selected player's hand
            gameState.playerHand = gameState.playerHands[playerNumber - 1];
            
            // Update the active player view button in the sidebar
            document.querySelectorAll('.player-view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-player="${playerNumber}"]`).classList.add('active');
            
            // Hide the login screen
            const loginOverlay = document.getElementById('login-overlay');
            if (loginOverlay) {
                loginOverlay.style.display = 'none';
            }
            
            // Show the main game elements
            const gameContainer = document.querySelector('.game-container');
            const cardPickerToggle = document.querySelector('.card-picker-toggle');
            const cardPickerBackdrop = document.querySelector('.card-picker-backdrop');
            const cardPickerSidebar = document.querySelector('.card-picker-sidebar');
            
            if (gameContainer) gameContainer.style.display = 'block';
            if (cardPickerToggle) cardPickerToggle.style.display = 'flex';
            if (cardPickerBackdrop) cardPickerBackdrop.style.display = 'block';
            if (cardPickerSidebar) cardPickerSidebar.style.display = 'block';

            // Spectator restrictions: if spectating, disable interactions and hide hands
            if (loginState.isSpectator) {
                // Hide personal hand area
                const handArea = document.getElementById('player-hand');
                if (handArea) handArea.style.display = 'none';
                // Disable draw/discard UI
                const stockPile = document.getElementById('stock-pile');
                if (stockPile) stockPile.style.pointerEvents = 'none';
                const discardPile = document.getElementById('discard-pile');
                if (discardPile) discardPile.style.pointerEvents = 'none';
            }
            
            // Note: Random starting player skips are already applied in applyFullState
            // No need to apply them again here
            
            // Update player name labels and turn display for the new perspective
            updatePlayerNameLabels();
            updateTurnDisplay();
            updatePlayerViewButtons();
            updateMeldAreaLabels();
            refreshChatMessages();
            updateCreateSetButtonVisibility();
            updateAtouValueDisplay();
            updateRunBaseValueDisplay();
            
            // Re-render the hand to show the selected player's cards
            renderHand();
            
            console.log(`Game started successfully from host - now viewing from Player ${playerNumber}'s perspective`);
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeCardPicker();
            setupDragAndDrop();
            initializeChat();
            newGame();
            
            // Add event listener for Create Run button
            const createRunBtn = document.getElementById('create-run-btn');
            if (createRunBtn) {
                createRunBtn.addEventListener('click', createRunFromSelected);
            }
            
            // Add event listener for Create Set button
            const createSetBtn = document.getElementById('create-set-btn');
            if (createSetBtn) {
                createSetBtn.addEventListener('click', createSetFromSelected);
            }
            
            // Add event listener for Extend Meld button
            const extendMeldBtn = document.getElementById('extend-meld-btn');
            if (extendMeldBtn) {
                extendMeldBtn.addEventListener('click', toggleExtendMeldMode);
            }
        
        // (dev-new-game-btn removed)
            
            
            // Add event listener for card picker toggle button
            const toggleBtn = document.getElementById('card-picker-toggle');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleCardPicker);
            }
            
            // Add event listener for backdrop click
            const backdrop = document.getElementById('card-picker-backdrop');
            if (backdrop) {
                backdrop.addEventListener('click', closeCardPicker);
            }
            
            // Close card picker on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && cardPickerOpen) {
                    closeCardPicker();
                }
            });
        });
    </script>
</body>
</html>
